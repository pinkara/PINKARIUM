<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Atelier Lenia - PINKARIUM</title>
<!-- Favicon -->
<link rel="icon" href="https://pinkara.github.io/PINKARIUM/favicon/favicon.ico" sizes="any">
<script src="https://cdn.tailwindcss.com"></script>

<!-- MathJax -->
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<!-- Prism & Fonts -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;700&family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

<style>
/* =========================
   Tokyo Night Theme
   ========================= */
:root {
  --tn-bg: #1a1b26;
  --tn-bg-2: #24283b;
  --tn-fg: #c0caf5;
  --tn-accent: #7aa2f7;
  --tn-cyan: #7dcfff;
  --tn-green: #9ece6a;
  --tn-orange: #ff9e64;
  --tn-magenta: #bb9af7;
  --tn-red: #f7768e;
  --tn-border: #414868;
  --tn-comment: #565f89;
}

body {
  background-color: var(--tn-bg);
  color: var(--tn-fg);
  font-family: 'Inter', sans-serif;
  margin: 0;
  display: flex;
  height: 100vh;
  overflow: hidden;
}

.app-container { display: flex; width: 100%; height: 100%; }

/* Canvas Area */
.canvas-area {
  flex: 1;
  position: relative;
  background: #000;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: hidden;
  border-right: 1px solid var(--tn-border);
}
canvas {
  /* The secret for crisp pixel art look */
  image-rendering: pixelated; 
  box-shadow: 0 0 30px rgba(0,0,0,0.5);
  cursor: crosshair;
  width: 100%;
  height: 100%;
}

/* Sidebar */
.sidebar {
  width: 400px;
  background: var(--tn-bg-2);
  display: flex;
  flex-direction: column;
  overflow: hidden;
  box-shadow: -5px 0 20px rgba(0,0,0,0.3);
  z-index: 10;
  flex-shrink: 0;
}

/* UI Components */
.header-box {
  padding: 12px 16px;
  border-bottom: 1px solid var(--tn-border);
  background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
}
.header-title-row { display: flex; align-items: center; gap: 12px; }
.header-icon {
  min-width: 36px; width: 36px; height: 36px;
  background: linear-gradient(135deg, var(--tn-green), var(--tn-cyan));
  border-radius: 8px;
  display: flex; align-items: center; justify-content: center;
  color: #1a1b26; font-weight: 800; font-family: 'JetBrains Mono', monospace; font-size: 1rem;
}
h1 { color: var(--tn-fg); font-weight: 800; font-size: 1.2rem; margin: 0; }
.subtitle { color: var(--tn-accent); font-size: 0.75rem; font-weight: 500; opacity: 0.9; }

.tabs { display: flex; background: rgba(0,0,0,0.2); gap: 1px; }
.tab-btn {
  flex: 1; padding: 10px; background: var(--tn-bg-2); border: none;
  border-bottom: 2px solid transparent; color: var(--tn-fg); opacity: 0.6;
  cursor: pointer; font-weight: 600; font-size: 0.8rem; transition: all 0.2s;
}
.tab-btn:hover { opacity: 1; background: rgba(255,255,255,0.02); }
.tab-btn.active { opacity: 1; border-bottom-color: var(--tn-green); color: var(--tn-green); background: rgba(158, 206, 106, 0.05); }

.content-scroll { flex: 1; overflow-y: auto; padding: 16px; }
.panel { display: none; animation: fadeIn 0.3s ease; }
.panel.active { display: block; }
@keyframes fadeIn {
  from { opacity: 0; transform: translateY(5px); }
  to { opacity: 1; transform: translateY(0); }
}

.control-group {
  background: rgba(0,0,0,0.2); border: 1px solid var(--tn-border);
  padding: 12px; border-radius: 6px; margin-bottom: 12px;
}
.control-header {
  font-size: 0.7rem; letter-spacing: 1px;
  color: var(--tn-magenta); margin-bottom: 8px; font-weight: 700;
}

input[type="range"] {
  width: 100%; accent-color: var(--tn-accent); margin-bottom: 5px; cursor: pointer; height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px;
}
input[type="number"] {
  padding: 4px; background: rgba(0,0,0,0.3); border: 1px solid var(--tn-border); 
  border-radius: 4px; font-family: 'JetBrains Mono'; font-size: 0.8rem; 
  color: var(--tn-cyan);
}
select {
  width: 100%; background: rgba(27, 27, 34, 0.986); color: var(--tn-fg); border: 1px solid var(--tn-border);
  padding: 6px; border-radius: 4px; font-size: 0.8rem; margin-bottom: 8px; outline: none; cursor: pointer;
}
.val-display { float: right; font-family: 'JetBrains Mono'; font-size: 0.75rem; color: var(--tn-cyan); }
label { font-size: 0.75rem; color: var(--tn-fg); display: block; margin-bottom: 4px; margin-top: 8px; }

.btn-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }

button.action-btn {
  width: 100%; padding: 8px; margin-top: 6px; border-radius: 4px;
  border: 1px solid var(--tn-border); background: rgba(122, 162, 247, 0.1);
  color: var(--tn-accent); font-weight: 600; cursor: pointer; transition: all 0.2s; font-size: 0.8rem;
}
button.action-btn:hover { background: var(--tn-accent); color: var(--tn-bg); }
button.secondary { background: transparent; border-color: var(--tn-border); color: var(--tn-fg); opacity: 0.8; }
button.secondary:hover { opacity: 1; border-color: var(--tn-fg); }
button.seed-btn { margin-top: 0; background: rgba(158, 206, 106, 0.1); color: var(--tn-green); border-color: var(--tn-green); }
button.seed-btn:hover { background: var(--tn-green); color: var(--tn-bg-2); }

pre { margin: 0 !important; border-radius: 6px; font-size: 0.7rem !important; border: 1px solid var(--tn-border); background: #16161e !important; padding: 10px !important; }

.kernel-viz {
  width: 100%; height: 50px; background: #16161e; border-radius: 4px;
  margin-bottom: 8px; position: relative; border: 1px solid var(--tn-border);
}
.kernel-info { font-size:0.7rem; color:var(--tn-comment); margin-top:6px; line-height: 1.4; }

@media (max-width: 800px) {
  .sidebar { width: 100%; height: 50%; position: absolute; bottom: 0; border-top: 1px solid var(--tn-border); }
  .canvas-area { height: 50%; border-bottom: 1px solid var(--tn-border); border-right: none; }
  .app-container { flex-direction: column; }
}
</style>
</head>
<body>

<div class="app-container">
  
  <div class="canvas-area" id="canvas-container">
    <canvas id="glCanvas"></canvas>
    
    <div style="position:absolute; top:15px; left:15px; font-family:'JetBrains Mono'; font-size:11px; color:var(--tn-fg); background:rgba(0,0,0,0.6); padding:6px 10px; border-radius:4px; pointer-events:none; backdrop-filter:blur(2px);">
      <div style="display:flex; align-items:center; gap:6px; margin-bottom:2px;">
        <span style="color:var(--tn-green); font-size:14px;">‚óè</span> <span id="sim-status">Actif (GPU)</span>
      </div>
      <div style="opacity:0.8;">
        FPS: <span id="fps-counter">0</span> | <span id="res-debug-info">Init...</span>
      </div>
    </div>
  </div>

  <div class="sidebar">
    <div class="header-box">
      <div class="header-title-row">
        <div class="header-icon">LEN</div>
        <div>
          <h1>LENIA \( (\text{Lenia}_K) \)</h1>
          <div class="subtitle">Simulateur WebGL Acceler√©</div>
        </div>
      </div>
    </div>

    <div class="tabs">
      <button class="tab-btn active" onclick="setTab('sim')">Labo</button>
      <button class="tab-btn" onclick="setTab('theory')">Th√©orie</button>
      <button class="tab-btn" onclick="setTab('code')">Code Shader</button>
    </div>

    <div class="content-scroll">
      
      <div id="panel-sim" class="panel active">
        
        <div class="control-group">
          <div class="control-header">üß¨ ESP√àCES ET GRAINE INITIALE</div>
          <select id="species-select" onchange="loadSpecies(this.value, true)">
            <option value="" disabled selected>-- Choisir une cr√©ature (Preset) --</option>
            <option value="orbium">O2 Orbium unicaudatus</option>
            <option value="geminium">3G Hydrogeminium natans</option>
          </select>
          <p class="kernel-info">
            Le choix d'une esp√®ce charge ses param√®tres de Kernel \( K \), de croissance \( G \) (Mu/Sigma) et son motif de cellules initiales.
          </p>
          <button class="action-btn seed-btn" onclick="resetGridWithSeed()" style="margin-top:10px;">
                ‚Üª R√©initialiser la Grille (Motif Initial)
            </button>
        </div>
        
        <div class="control-group">
          <div class="control-header">‚è≥ TEMPS \( (T) \) ET VITESSE</div>
          
          <label>
            Temps \(T\) (Taux de mise √† jour \(dt=1/T\))
            <span id="val-T" class="val-display">10.0</span>
          </label>
          <input type="range" id="inp-T" min="1" max="20" step="0.5" value="10.0" oninput="updateT(this.value)">
          <p class="kernel-info">Contr√¥le la rapidit√© de l'√©volution. \(T\) √©lev√© \(\rightarrow\) mises √† jour plus douces.</p>
          
        </div>

        <div class="control-group">
          <div class="control-header">üìà FONCTION DE CROISSANCE \(G( \mu, \sigma) \)</div>
          <p class="kernel-info" id="kernel-count-info">Param√®tres du Kernel principal (WebGL).</p>
          
          <!-- Kernel Visualization -->
          <div id="kernel-graph" class="kernel-viz"></div>
          
          <label>
            \(\mu\) (Mu) - Cible de croissance
            <span id="val-mu" class="val-display">0.1500</span>
          </label>
          <div class="flex gap-2 items-center"> 
            <input type="range" id="inp-mu" min="0.05" max="0.5" step="0.001" class="flex-grow">
            <input type="number" id="inp-mu-precise" min="0.05" max="0.5" step="0.0001" value="0.1500" style="width: 100px;">
          </div>
          
          <label>
            \(\sigma\) (Sigma) - Tol√©rance
            <span id="val-sigma" class="val-display">0.0170</span>
          </label>
          <div class="flex gap-2 items-center">
            <input type="range" id="inp-sigma" min="0.001" max="0.15" step="0.001" class="flex-grow">
            <input type="number" id="inp-sigma-precise" min="0.001" max="0.15" step="0.0001" value="0.0170" style="width: 100px;">
          </div>
        </div>
        
        <div class="control-group">
          <div class="control-header">üåÄ FILTRE DE PERCEPTION (Kernel \( K \))</div>
          
          <label>
            Rayon Principal \(R\) (Taille de la Perception)
            <span id="val-R" class="val-display">16</span>
          </label>
          <input type="range" id="inp-R" min="5" max="40" step="1" value="16" oninput="updateR(this.value)">
          
        </div>
        

        <div class="control-group">
            <div class="control-header">üñºÔ∏è Affichage et Grille (GPU)</div>
            
            <label style="color:var(--tn-green);">
              ‚òÖ Densit√© Verticale (Hauteur de Grille)
              <span id="val-sim-res" class="val-display">256 px</span>
            </label>
            <input type="range" id="inp-sim-res" min="128" max="600" step="16" value="256" onchange="setSimResolution(this.value)">
            <p class="kernel-info">La largeur s'adapte automatiquement au ratio de l'√©cran.</p>
            
            <hr style="border-color:var(--tn-border); margin:10px 0; opacity:0.5;">

            <label>
              Taille Affich√©e (Zoom Visuel)
              <span id="val-zoom" class="val-display">100%</span>
            </label>
            <input type="range" id="inp-zoom" min="0.5" max="3.0" step="0.1" value="1.0" oninput="updateZoom(this.value)">

            <select id="palette-select" onchange="changePalette(this.value)" style="margin-top:12px;">
              <option value="0">Tokyo Night</option>
              <option value="1">Magma (Intense)</option>
              <option value="2">Viridis (Biologique)</option>
              <option value="3">Lenia Blue</option>
              <option value="4">Enceladus</option>
              <option value="5">Monochrome</option>
            </select>
            
            <div class="btn-grid">
              <button class="action-btn secondary" onclick="togglePause()" id="btn-pause">‚è∏ Pause</button>
              <button class="action-btn secondary" onclick="resetGridWithSeed(true)">üóë Nettoyer</button>
            </div>
        </div>
        
        <p style="font-size:0.7rem; color:var(--tn-cyan); opacity:0.7; text-align:center;">
          üñ±Ô∏è Clic Gauche : Dessiner | Clic Droit : Effacer
        </p>
      </div>

      <!-- THEORY PANEL -->
      <div id="panel-theory" class="panel">
        <h2 style="color:var(--tn-green); font-size:1rem; margin-bottom:10px;">L'√©quation de Lenia Multi-Kernel \((\text{Lenia}_K)\)</h2>
        <p style="font-size:0.85rem; margin-bottom:15px; line-height:1.5; color:var(--tn-fg);">
          Lenia g√©n√©ralise le jeu de la Vie en introduisant des fonctions continues. L'√©volution du champ \(A\) est donn√©e par :
        </p>
        
        <div style="background:rgba(0,0,0,0.3); padding:15px; border-radius:8px; margin:15px 0; border-left:3px solid var(--tn-accent);">
          $$\frac{\partial A}{\partial t} = \sum_{k=1}^{N_K} h_k \cdot G_k(U_k, \mu_k, \sigma_k)$$
        </div>
        
        <p style="font-size:0.85rem; margin-bottom:15px; line-height:1.5; color:var(--tn-fg);">
          O√π \(U_k\) est la Perception (Convolution) pour le Kernel \(k\): \(U_k = K_k * A\).
        </p>
        
        <h3 style="color:var(--tn-cyan); font-size:0.9rem; margin-top:15px; margin-bottom:5px;">1. Perception (Convolution) \(U = K * A\) </h3>
        <p style="font-size:0.8rem; line-height:1.4;">
          Chaque cellule convolue son voisinage avec un Kernel \(K_k\) (un filtre en anneau gaussien), cr√©ant une carte de perception \(U_k\).
          <ul style="margin-left:20px; font-size:0.75rem;">
            <li><strong>Filtre \(K\) :</strong>__ D√©finit la forme et le rayon de l'anneau de perception.</li>
            <li><strong>Multi-Kernel :</strong> Certaines esp√®ces (comme 'Fish') utilisent plusieurs filtres \(K_k\) simultan√©ment, chacun ayant son propre rayon \(R_k\) et sa propre forme.</li>
          </ul>
        </p>
        
        <h3 style="color:var(--tn-cyan); font-size:0.9rem; margin-top:15px; margin-bottom:5px;">2. Fonction de Croissance (Physiologie) \(G(\mu, \sigma)\)</h3>
        <p style="font-size:0.8rem; line-height:1.4;">
          La fonction de croissance \(G_k\) est une cloche gaussienne qui convertit la masse per√ßue \(U_k\) en un taux de croissance/d√©croissance (entre -1 et +1).
          <ul style="margin-left:20px; font-size:0.75rem;">
            <li>\(\mu\): Cible de croissance (le niveau de \(U\) pour une croissance maximale).</li>
            <li>\( \sigma\): Tol√©rance (la largeur autour de $\mu$ o√π la croissance est positive).</li>
            <li>\(h_k\): Hauteur/Poids : Facteur de mise √† l'√©chelle pour l'influence totale de ce Kernel/Croissance.</li>
          </ul>
        </p>
      </div>

      <!-- CODE PANEL -->
      <div id="panel-code" class="panel">
        <p style="font-size:0.8rem; color:var(--tn-comment); margin-bottom:8px;">Le c≈ìur de la simulation (GLSL Fragment Shader) :</p>
        <pre><code class="language-glsl">precision mediump float;
// Uniforms (Param√®tres pass√©s par JS)
uniform sampler2D u_texture;
uniform float u_R;
uniform float u_mu;
uniform float u_sigma;
uniform float u_dt;

// Fonction de noyau (Gaussian Ring)
float kernel(float r) {
    float k = exp(-pow((r - 0.5), 2.0) / 0.15); 
    return k;
}

// Fonction de croissance
float growth(float U, float mu, float sigma) {
    return 2.0 * exp(-pow((U - mu), 2.0) / (2.0 * sigma * sigma)) - 1.0;
}

void main() {
    // 1. Convolution (Boucle optimis√©e)
    float sum = 0.0;
    float totalWeight = 0.0;
    
    for(float x = -R; x <= R; x++) {
        for(float y = -R; y <= R; y++) {
             // ... √©chantillonnage de texture ...
             sum += val * w;
        }
    }
    
    float U = sum / totalWeight;

    // 2. √âvolution
    float current = texture2D(u_texture, uv).r;
    float next = clamp(current + growth(U, u_mu, u_sigma) * u_dt, 0.0, 1.0);
    
    gl_FragColor = vec4(next, 0.0, 0.0, 1.0);
}</code></pre>
      </div>

    </div>
  </div>
</div>

<!-- SHADERS GLSL -->
<script id="vs" type="x-shader/x-vertex">
    attribute vec2 position;
    void main() { gl_Position = vec4(position, 0.0, 1.0); }
</script>

<script id="fs-sim" type="x-shader/x-fragment">
    precision mediump float;
    uniform vec2 u_resolution;
    uniform sampler2D u_texture;
    uniform float u_R;
    uniform float u_mu;
    uniform float u_sigma;
    uniform float u_dt;
    uniform vec3 u_mouse; // x, y, click (1.0 or -1.0 for erase)

    float gaussian(float x, float m, float s) {
        return exp(-pow((x - m), 2.0) / (2.0 * s * s));
    }

    float growth(float U, float mu, float sigma) {
        return 2.0 * gaussian(U, mu, sigma) - 1.0;
    }

    void main() {
        vec2 uv = gl_FragCoord.xy / u_resolution;
        vec2 pixel = 1.0 / u_resolution;
        
        float sum = 0.0;
        float totalWeight = 0.0;
        float radius = u_R; 
        
        // Optimisation boucle
        float stepSize = max(1.0, radius / 10.0); 

        // Boucle fixe large pour couvrir le rayon
        for(float y = -20.0; y <= 20.0; y+=1.0) {
            for(float x = -20.0; x <= 20.0; x+=1.0) {
                // Mapping pour que la zone 20x20 couvre le rayon R
                vec2 offset = vec2(x, y) * (radius / 20.0);
                
                float dist = length(offset);
                if (dist > radius) continue;
                
                float r_norm = dist / radius;
                float weight = gaussian(r_norm, 0.5, 0.15);
                
                // IMPORTANT : fract() ici assure le tore (boucle infini) manuellement
                // cela nous permet d'utiliser CLAMP_TO_EDGE et n'importe quelle r√©solution
                vec2 samplePos = fract(uv + offset * pixel);
                
                float val = texture2D(u_texture, samplePos).r;
                
                sum += val * weight;
                totalWeight += weight;
            }
        }
        
        float U = sum / totalWeight;
        float current = texture2D(u_texture, uv).r;
        float next = clamp(current + growth(U, u_mu, u_sigma) * u_dt, 0.0, 1.0);

        // Interaction Souris
        float d = distance(gl_FragCoord.xy, u_mouse.xy);
        if (abs(u_mouse.z) > 0.5 && d < max(u_R, 5.0)) {
            if (u_mouse.z > 0.0) next = min(1.0, next + 0.8); // Draw
            else next = max(0.0, next - 0.8); // Erase
        }

        gl_FragColor = vec4(next, 0.0, 0.0, 1.0);
    }
</script>

<script id="fs-draw" type="x-shader/x-fragment">
    precision mediump float;
    uniform sampler2D u_texture;
    uniform vec2 u_resolution;
    uniform int u_palette;

    vec3 pal_tokyo(float t) {
        if(t < 0.05) return vec3(0.102, 0.106, 0.149); // #1a1b26
        if(t < 0.5) return mix(vec3(0.102, 0.106, 0.149), vec3(0.478, 0.635, 0.969), (t-0.05)/0.45);
        return mix(vec3(0.478, 0.635, 0.969), vec3(0.969, 0.969, 0.969), (t-0.5)/0.5);
    }

    vec3 pal_blue(float t) {
        vec3 col = mix(vec3(0.05, 0.05, 0.1), vec3(0.5, 0.9, 1.0), t);
        if(t < 0.01) col = vec3(0.02, 0.02, 0.05);
        return col;
    }

    vec3 pal_enceladus(float t) {
        vec3 c1 = vec3(0.0, 0.1, 0.2);
        vec3 c2 = vec3(0.8, 0.95, 1.0);
        return mix(c1, c2, sqrt(t));
    }
    
    vec3 pal_magma(float t) {
        return vec3(t, t*t, t*t*t) + vec3(0.2*t, 0.0, 0.4*t); 
    }

    vec3 pal_viridis(float t) {
        return vec3(t*0.2, t, t*0.4);
    }

    void main() {
        vec2 uv = gl_FragCoord.xy / u_resolution;
        float val = texture2D(u_texture, uv).r;
        
        vec3 col = vec3(val);
        if (u_palette == 0) col = pal_tokyo(val);
        else if (u_palette == 1) col = pal_magma(val);
        else if (u_palette == 2) col = pal_viridis(val);
        else if (u_palette == 3) col = pal_blue(val);
        else if (u_palette == 4) col = pal_enceladus(val);
        else col = vec3(val);

        gl_FragColor = vec4(col, 1.0);
    }
</script>

<script>
// === WEBGL ENGINE ===

const canvas = document.getElementById('glCanvas');
// Alpha false = meilleure perf et pas de blending bizarre avec le fond CSS
const gl = canvas.getContext('webgl', { preserveDrawingBuffer: true, alpha: false });
const container = document.getElementById('canvas-container');

if (!gl) alert("WebGL non support√© !");

// Configuration Globale
// On s√©pare Width et Height pour g√©rer les ratios d'√©cran bizarres
let SIM_W = 256;
let SIM_H = 256;
let TARGET_H = 256; // La valeur cible d√©finie par le slider

let params = {
    R: 16,
    mu: 0.15,
    sigma: 0.017,
    dt: 0.1,
    paused: false,
    palette: 0
};

// Shaders compilation
function createShader(gl, type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error(gl.getShaderInfoLog(shader));
        gl.deleteShader(shader);
        return null;
    }
    return shader;
}

function createProgram(gl, vsSource, fsSource) {
    const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
    const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
    const prog = gl.createProgram();
    gl.attachShader(prog, vs);
    gl.attachShader(prog, fs);
    gl.linkProgram(prog);
    return prog;
}

const vsSrc = document.getElementById('vs').text;
const simProg = createProgram(gl, vsSrc, document.getElementById('fs-sim').text);
const drawProg = createProgram(gl, vsSrc, document.getElementById('fs-draw').text);

// Buffers (Quad)
const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 1,-1, -1,1, 1,1]), gl.STATIC_DRAW);

// Textures Ping-Pong
let textures = [], framebuffers = [];
let currentIdx = 0;

function initTextures() {
    // Nettoyage complet
    textures.forEach(t => gl.deleteTexture(t));
    framebuffers.forEach(f => gl.deleteFramebuffer(f));
    textures = []; framebuffers = [];

    // Important pour les largeurs impaires
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);

    for(let i=0; i<2; i++) {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, SIM_W, SIM_H, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        
        // CORRECTION MAJEURE : On utilise CLAMP_TO_EDGE car SIM_W/H ne sont pas forc√©ment des puissances de 2
        // Le bouclage (tore) est g√©r√© math√©matiquement dans le shader via fract()
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        
        textures.push(tex);

        const fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
        
        // Check fb status
        if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) !== gl.FRAMEBUFFER_COMPLETE) {
            console.error("Framebuffer incomplet !");
        }
        framebuffers.push(fb);
    }
    
    // Debug info update
    document.getElementById('res-debug-info').innerText = `${SIM_W} x ${SIM_H}`;
}

// Fonction pour uploader des donn√©es initiales (Seed)
function uploadData(dataArray) {
    gl.bindTexture(gl.TEXTURE_2D, textures[currentIdx]);
    const buffer = new Uint8Array(SIM_W * SIM_H * 4);
    
    // Si pas de pattern, on fait du bruit al√©atoire
    if (!dataArray) {
        for(let i=0; i<SIM_W*SIM_H; i++) {
            let val = (Math.random() > 0.85 ? 255 : 0);
            buffer[i*4] = val; buffer[i*4+3] = 255;
        }
    } else {
        // Injection du pattern centr√©
        // dataArray est suppos√© carr√© (pattern de l'esp√®ce) ou rectangle
        // Ici on suppose le format array de arrays du preset
        const pH = dataArray.length;
        const pW = dataArray[0].length;
        
        const offY = Math.floor((SIM_H - pH)/2);
        const offX = Math.floor((SIM_W - pW)/2);
        
        for(let y=0; y<pH; y++) {
            for(let x=0; x<pW; x++) {
                // Coordonn√©es dans la grille globale
                // On utilise le modulo pour √™tre safe
                let ty = (offY + y + SIM_H) % SIM_H;
                let tx = (offX + x + SIM_W) % SIM_W;
                
                let idx = (ty * SIM_W + tx) * 4;
                buffer[idx] = dataArray[y][x] * 255;
                buffer[idx+3] = 255;
            }
        }
    }
    
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, SIM_W, SIM_H, 0, gl.RGBA, gl.UNSIGNED_BYTE, buffer);
}

// === INTERACTION & LOGIQUE ===

let mousePos = { x: 0, y: 0, click: 0 }; 

function updateMouse(e) {
    const rect = canvas.getBoundingClientRect();
    let x = (e.clientX - rect.left) / rect.width;
    let y = 1.0 - (e.clientY - rect.top) / rect.height; 
    
    mousePos.x = x * SIM_W;
    mousePos.y = y * SIM_H;
}

canvas.addEventListener('mousedown', e => {
    mousePos.click = (e.button === 2) ? -1 : 1;
    updateMouse(e);
});
canvas.addEventListener('mousemove', e => {
    if(mousePos.click !== 0) updateMouse(e);
});
window.addEventListener('mouseup', () => mousePos.click = 0);
canvas.addEventListener('contextmenu', e => e.preventDefault());


// === BOUCLE PRINCIPALE ===

function step() {
    if(!params.paused || mousePos.click !== 0) {
        gl.useProgram(simProg);
        gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffers[1 - currentIdx]);
        // Viewport adapt√© √† la grille de simulation
        gl.viewport(0, 0, SIM_W, SIM_H);

        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, textures[currentIdx]);
        
        gl.uniform1i(gl.getUniformLocation(simProg, "u_texture"), 0);
        // Important: Passer les dimensions s√©par√©es
        gl.uniform2f(gl.getUniformLocation(simProg, "u_resolution"), SIM_W, SIM_H);
        gl.uniform1f(gl.getUniformLocation(simProg, "u_R"), params.R);
        gl.uniform1f(gl.getUniformLocation(simProg, "u_mu"), params.mu);
        gl.uniform1f(gl.getUniformLocation(simProg, "u_sigma"), params.sigma);
        gl.uniform1f(gl.getUniformLocation(simProg, "u_dt"), params.dt);
        gl.uniform3f(gl.getUniformLocation(simProg, "u_mouse"), mousePos.x, mousePos.y, mousePos.click);

        const posLoc = gl.getAttribLocation(simProg, "position");
        gl.enableVertexAttribArray(posLoc);
        gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

        currentIdx = 1 - currentIdx;
    }

    // Rendu √©cran (upscale)
    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.useProgram(drawProg);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, textures[currentIdx]);
    
    gl.uniform1i(gl.getUniformLocation(drawProg, "u_texture"), 0);
    gl.uniform2f(gl.getUniformLocation(drawProg, "u_resolution"), canvas.width, canvas.height);
    gl.uniform1i(gl.getUniformLocation(drawProg, "u_palette"), params.palette);

    const posLocDraw = gl.getAttribLocation(drawProg, "position");
    gl.enableVertexAttribArray(posLocDraw);
    gl.vertexAttribPointer(posLocDraw, 2, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    requestAnimationFrame(step);
    frameCount++;
}

let frameCount = 0;
setInterval(() => {
    document.getElementById('fps-counter').innerText = frameCount;
    frameCount = 0;
}, 1000);

// === UI BINDINGS & SPECIES DATA ===

const SPECIES_DATA = {
    "orbium": { name: "Orbium", R: 13, T: 10, mu: 0.15, sigma: 0.015, cells: [[0,0,0,0,0,0,0.1,0.14,0.1,0,0,0.03,0.03,0,0,0.3,0,0,0,0], [0,0,0,0,0,0.08,0.24,0.3,0.3,0.18,0.14,0.15,0.16,0.15,0.09,0.2,0,0,0,0], [0,0,0,0,0,0.15,0.34,0.44,0.46,0.38,0.18,0.14,0.11,0.13,0.19,0.18,0.45,0,0,0], [0,0,0,0,0.06,0.13,0.39,0.5,0.5,0.37,0.06,0,0,0,0.02,0.16,0.68,0,0,0], [0,0,0,0.11,0.17,0.17,0.33,0.4,0.38,0.28,0.14,0,0,0,0,0,0.18,0.42,0,0], [0,0,0.09,0.18,0.13,0.06,0.08,0.26,0.32,0.32,0.27,0,0,0,0,0,0,0.82,0,0], [0.27,0,0.16,0.12,0,0,0,0.25,0.38,0.44,0.45,0.34,0,0,0,0,0,0.22,0.17,0], [0,0.07,0.2,0.02,0,0,0,0.31,0.48,0.57,0.6,0.57,0,0,0,0,0,0,0.49,0], [0,0.59,0.19,0,0,0,0,0.2,0.57,0.69,0.76,0.76,0.49,0,0,0,0,0,0.36,0], [0,0.58,0.19,0,0,0,0,0,0.67,0.83,0.9,0.92,0.87,0.12,0,0,0,0,0.22,0.07], [0,0,0.46,0,0,0,0,0,0.7,0.93,1,1,1,0.61,0,0,0,0,0.18,0.11], [0,0,0.82,0,0,0,0,0,0.47,1,1,0.98,1,0.96,0.27,0,0,0,0.19,0.1], [0,0,0.46,0,0,0,0,0,0.25,1,1,0.84,0.92,0.97,0.54,0.14,0.04,0.1,0.21,0.05], [0,0,0,0.4,0,0,0,0,0.09,0.8,1,0.82,0.8,0.85,0.63,0.31,0.18,0.19,0.2,0.01], [0,0,0,0.36,0.1,0,0,0,0.05,0.54,0.86,0.79,0.74,0.72,0.6,0.39,0.28,0.24,0.13,0], [0,0,0,0.01,0.3,0.07,0,0,0.08,0.36,0.64,0.7,0.64,0.6,0.51,0.39,0.29,0.19,0.04,0], [0,0,0,0,0.1,0.24,0.14,0.1,0.15,0.29,0.45,0.53,0.52,0.46,0.4,0.31,0.21,0.08,0,0], [0,0,0,0,0,0.08,0.21,0.21,0.22,0.29,0.36,0.39,0.37,0.33,0.26,0.18,0.09,0,0,0], [0,0,0,0,0,0,0.03,0.13,0.19,0.22,0.24,0.24,0.23,0.18,0.13,0.05,0,0,0,0], [0,0,0,0,0,0,0,0,0.02,0.06,0.08,0.09,0.07,0.05,0.01,0,0,0,0,0]] },
    "geminium": { name: "Hydrogeminium", R: 18, T: 10, mu: 0.26, sigma: 0.036, cells: [[0,0,0,0,0,0,0.2,0.5,0.2,0,0,0,0,0], [0,0,0.5,0.8,0.9,0.8,0.5,0,0,0], [0,0.2,0.7,1.0,1.0,1.0,0.7,0.2,0], [0,0.1,0.5,0.8,1.0,0.8,0.5,0.1,0], [0,0,0,0.2,0.5,0.2,0,0,0]] }
};

let currentSpeciesKey = 'orbium';

// --- FONCTIONS DE LOGIQUE ---

function updateKernelGraph() {
    const el = document.getElementById('kernel-graph');
    if(!el) return;
    el.innerHTML = ''; 
    const cv = document.createElement('canvas');
    cv.width = el.clientWidth; cv.height = el.clientHeight;
    el.appendChild(cv);
    const cx = cv.getContext('2d');
    const w = cv.width; const h = cv.height;
    
    // Fonction Bell JS pour la visualisation
    const bell = (x, m, s) => Math.exp(-Math.pow((x-m)/s, 2) / 2);
    
    cx.clearRect(0,0,w,h);
    cx.strokeStyle = '#414868'; cx.beginPath(); cx.moveTo(0, h/2); cx.lineTo(w, h/2); cx.stroke();
    cx.strokeStyle = '#9ece6a'; cx.lineWidth = 2; cx.beginPath();
    for(let i=0; i<w; i++) {
        const u = i / w; 
        const val = (bell(u, params.mu, params.sigma) * 2 - 1); 
        const y = h/2 - (val * h/2.5);
        if (i===0) cx.moveTo(i, y); else cx.lineTo(i, y);
    }
    cx.stroke();
    
    const muX = params.mu * w;
    cx.strokeStyle = '#7aa2f7'; cx.setLineDash([2, 2]);
    cx.beginPath(); cx.moveTo(muX, 0); cx.lineTo(muX, h); cx.stroke();
}

window.updateR = function(v) { params.R = parseFloat(v); document.getElementById('val-R').innerText = params.R; }
window.updateT = function(v) { params.dt = 1.0 / parseFloat(v); document.getElementById('val-T').innerText = v; }
window.updateZoom = function(v) {
    canvas.style.transform = `scale(${v})`;
    document.getElementById('val-zoom').innerText = Math.round(v * 100) + "%";
}

// Changement de pr√©cision : met √† jour la TARGET_H
window.setSimResolution = function(v) {
    TARGET_H = parseInt(v);
    document.getElementById('val-sim-res').innerText = TARGET_H + " px";
    // On relance le resize pour recalculer SIM_W
    handleResize();
}

function updateMuSigma(m, s) {
    params.mu = parseFloat(m);
    params.sigma = parseFloat(s);
    
    document.getElementById('val-mu').innerText = params.mu.toFixed(4);
    document.getElementById('inp-mu').value = params.mu;
    document.getElementById('inp-mu-precise').value = params.mu.toFixed(4);
    document.getElementById('val-sigma').innerText = params.sigma.toFixed(4);
    document.getElementById('inp-sigma').value = params.sigma;
    document.getElementById('inp-sigma-precise').value = params.sigma.toFixed(4);
    
    updateKernelGraph();
}

document.getElementById('inp-mu').oninput = e => updateMuSigma(e.target.value, params.sigma);
document.getElementById('inp-mu-precise').onchange = e => updateMuSigma(e.target.value, params.sigma);
document.getElementById('inp-sigma').oninput = e => updateMuSigma(params.mu, e.target.value);
document.getElementById('inp-sigma-precise').onchange = e => updateMuSigma(params.mu, e.target.value);

window.togglePause = function() {
    params.paused = !params.paused;
    const btn = document.getElementById('btn-pause');
    btn.innerText = params.paused ? "‚ñ∂ Reprendre" : "‚è∏ Pause";
    btn.classList.toggle('secondary');
    document.getElementById('sim-status').innerText = params.paused ? "Pause" : "Actif (GPU)";
    document.getElementById('sim-status').style.color = params.paused ? "var(--tn-orange)" : "var(--tn-green)";
}

window.changePalette = function(v) { params.palette = parseInt(v); }

window.loadSpecies = function(name, doSeed) {
    if(!SPECIES_DATA[name]) return;
    currentSpeciesKey = name;
    const s = SPECIES_DATA[name];
    params.R = s.R;
    params.dt = 1.0 / s.T;
    updateMuSigma(s.mu, s.sigma);
    document.getElementById('val-R').innerText = s.R;
    document.getElementById('inp-R').value = s.R;
    document.getElementById('val-T').innerText = s.T;
    document.getElementById('inp-T').value = s.T;
    
    if(doSeed) window.resetGridWithSeed(false);
}

window.resetGridWithSeed = function(empty=false) {
    if(empty) { uploadData(null); return; }
    
    const s = SPECIES_DATA[currentSpeciesKey];
    if(!s || !s.cells) { uploadData(null); return; }
    
    // Le motif est envoy√© tel quel √† uploadData qui se charge du centrage sur GPU
    uploadData(s.cells);
}

window.setTab = function(id) {
  document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  const p = document.getElementById('panel-'+id); if(p) p.classList.add('active');
  const btns = document.querySelectorAll('.tab-btn');
  if(id==='sim' && btns[0]) btns[0].classList.add('active');
  if(id==='theory' && btns[1]) btns[1].classList.add('active');
  if(id==='code' && btns[2]) btns[2].classList.add('active');
}

// Redimensionnement Intelligent
function handleResize() {
    const parent = container;
    const w = parent.clientWidth;
    const h = parent.clientHeight;
    
    canvas.width = w;
    canvas.height = h;

    // Calcul de la taille de grille pour garder les cellules carr√©es (Isotropie)
    const aspect = w / h;
    SIM_H = TARGET_H; 
    SIM_W = Math.round(SIM_H * aspect);

    // On s'assure que c'est pair (optionnel mais bon pour la m√©moire)
    if(SIM_W % 2 !== 0) SIM_W++;
    if(SIM_H % 2 !== 0) SIM_H++;

    console.log(`Resize: Screen ${w}x${h} -> Grid ${SIM_W}x${SIM_H}`);
    
    // R√©init textures et injection du dernier motif
    initTextures();
    window.resetGridWithSeed(false);
}

window.addEventListener('resize', () => {
    // Petit debounce pour √©viter de spammer le GPU
    clearTimeout(window.resizeTimer);
    window.resizeTimer = setTimeout(handleResize, 100);
});

// Init
// On attend un tick pour que le layout CSS soit fini
setTimeout(() => {
    handleResize();
    loadSpecies('orbium', true);
    updateKernelGraph();
    step(); 
}, 50);

</script>
</body>
</html>
