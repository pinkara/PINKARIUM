<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Atelier A* — PINKARIUM</title>
  <!-- Favicon -->
    <link rel="icon" href="https://pinkara.github.io/PINKARIUM/favicon/favicon.ico" sizes="any">
    <link rel="icon" type="image/png" href="https://pinkara.github.io/PINKARIUM/favicon/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="https://pinkara.github.io/PINKARIUM/favicon/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://pinkara.github.io/PINKARIUM/favicon/favicon-48x48.png" sizes="48x48">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="icon" type="image/png" href="https://pinkara.github.io/PINKARIUM/favicon/android-chrome-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="https://pinkara.github.io/PINKARIUM/favicon/android-chrome-512x512.png" sizes="512x512">
    <link rel="apple-touch-icon" href="https://pinkara.github.io/PINKARIUM/favicon/apple-touch-icon.png">
    <link rel="mask-icon" href="https://pinkara.github.io/PINKARIUM/favicon/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="icon" href="https://pinkara.github.io/PINKARIUM/favicon/favicon.svg" type="image/svg+xml">
  <!-- Tailwind (Mise en page) -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Police Inter & JetBrains Mono -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">

  <!-- Prism CSS (Custom Tokyo Night) -->
  <style>
    :root{
      --tn-bg: #1a1b26;
      --tn-bg-2: #0f1724;
      --tn-foreground: #a9b1d6;
      --tn-white: #c0caf5;
      --tn-blue: #7aa2f7;
      --tn-cyan: #7dcfff;
      --tn-green: #9ece6a;
      --tn-yellow: #e0af68;
      --tn-orange: #ff9e64;
      --tn-magenta: #bb9af7;
      --tn-red: #f7768e;
      --tn-comment: #565f89;
      --tn-border: #414868;
      --tn-storm: #24283b;
    }
    body { background: var(--tn-bg); color: var(--tn-foreground); font-family: 'Inter', sans-serif; margin: 0; overflow-x: hidden; }
    
    /* Layout Grid */
    .container { max-width: 1400px; margin: 0 auto; padding: 20px; display: grid; grid-template-columns: 1fr 500px; gap: 20px; height: 100vh; }
    @media (max-width: 1100px) { .container { grid-template-columns: 1fr; height: auto; } }

    /* Cards */
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      border: 1px solid rgba(122,162,247,0.1);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
      display: flex; flex-direction: column;
    }

    /* Titles */
    h1 { color: var(--tn-white); font-weight: 800; font-size: 1.5rem; margin:0; }
    h2 { color: var(--tn-blue); font-weight: 700; font-size: 1.1rem; margin: 0 0 10px 0; }
    h3 { color: var(--tn-cyan); font-weight: 600; font-size: 0.95rem; margin: 15px 0 8px 0; }

    /* Controls */
    .btn { background: var(--tn-blue); color: #000; padding: 8px 16px; border-radius: 8px; font-weight: 600; border: none; cursor: pointer; transition: all 0.2s; }
    .btn:hover { filter: brightness(1.1); transform: translateY(-1px); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    .btn.secondary { background: transparent; border: 1px solid var(--tn-border); color: var(--tn-white); }
    
    /* Grid System */
    .grid-container {
      background: var(--tn-storm);
      border-radius: 8px;
      padding: 20px;
      border: 1px solid var(--tn-border);
      display: flex; justify-content: center; align-items: center;
      flex: 1; overflow: auto;
    }
    .grid { display: grid; gap: 4px; }
    .cell {
      width: 40px; height: 40px;
      background: var(--tn-bg-2);
      border: 1px solid rgba(255,255,255,0.05);
      border-radius: 6px;
      display: flex; align-items: center; justify-content: center;
      font-size: 0.7rem; color: rgba(255,255,255,0.3);
      cursor: pointer;
      position: relative;
      transition: transform 0.1s, background 0.2s;
    }
    .cell:hover { border-color: var(--tn-blue); }
    
    /* Cell States */
    .cell.wall { background: var(--tn-border); border-color: var(--tn-comment); }
    .cell.start { background: var(--tn-blue); color: #000; box-shadow: 0 0 15px rgba(122,162,247,0.4); transform: scale(1.1); z-index: 2; }
    .cell.goal { background: var(--tn-green); color: #000; box-shadow: 0 0 15px rgba(158,206,106,0.4); transform: scale(1.1); z-index: 2; }
    .cell.path { background: var(--tn-magenta); color: #000; animation: pulsePath 0.5s ease-out; }
    .cell.open { background: rgba(255, 158, 100, 0.2); border-color: var(--tn-orange); }
    .cell.closed { background: rgba(122, 162, 247, 0.1); border-color: rgba(122, 162, 247, 0.2); }
    
    /* Values in cells */
    .cell .val-f { position: absolute; top: 2px; left: 2px; font-weight: bold; font-size: 0.65rem; color: var(--tn-white); }
    .cell .val-g { position: absolute; bottom: 2px; left: 2px; font-size: 0.55rem; color: var(--tn-green); }
    .cell .val-h { position: absolute; bottom: 2px; right: 2px; font-size: 0.55rem; color: var(--tn-yellow); }

    /* Tab Navigation */
    .nav-tabs { display: flex; gap: 10px; margin-bottom: 15px; border-bottom: 1px solid var(--tn-border); padding-bottom: 10px; }
    .tab-btn { background: none; border: none; color: var(--tn-comment); cursor: pointer; font-weight: 600; padding: 5px 10px; transition: color 0.2s; }
    .tab-btn.active { color: var(--tn-cyan); border-bottom: 2px solid var(--tn-cyan); }
    .tab-btn:hover { color: var(--tn-white); }

    /* Slides */
    .slide { display: none; height: 100%; overflow-y: auto; }
    .slide.active { display: block; animation: fadeIn 0.3s ease; }

    /* Prism Custom */
    pre[class*="language-"] {
      background: var(--tn-bg-2) !important;
      border: 1px solid var(--tn-border);
      border-radius: 8px;
      padding: 15px;
      font-family: 'JetBrains Mono', monospace !important;
      font-size: 0.8rem;
    }
    
    /* Syntax Colors */
    .token.comment { color: var(--tn-comment) !important; font-style: italic; }
    .token.keyword { color: var(--tn-magenta) !important; }
    .token.function { color: var(--tn-blue) !important; }
    .token.number { color: var(--tn-orange) !important; }
    .token.string { color: var(--tn-green) !important; }
    .token.operator { color: var(--tn-cyan) !important; }

    /* Interactive Tokens */
    .clickable { cursor: help; text-decoration: underline dotted rgba(122, 162, 247, 0.5); }
    .clickable:hover { color: var(--tn-white) !important; background: rgba(122, 162, 247, 0.1); }

    /* Popover */
    .popover-panel {
      position: fixed; z-index: 10000;
      background: var(--tn-bg); border: 1px solid var(--tn-border); border-left: 3px solid var(--tn-blue);
      border-radius: 8px; padding: 12px 16px; width: 300px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.6); pointer-events: none; opacity: 0; transform: translateY(5px);
      transition: opacity 0.2s, transform 0.2s;
    }
    .popover-visible { opacity: 1; transform: translateY(0); }
    .popover-title { color: var(--tn-blue); font-weight: 700; margin-bottom: 4px; }
    .popover-body { font-size: 0.85rem; line-height: 1.5; }

    /* Math Bars */
    .bar-row { display: grid; grid-template-columns: 80px 1fr 40px; align-items: center; gap: 10px; margin-bottom: 8px; font-size: 0.9rem; }
    .bar-bg { background: var(--tn-bg-2); height: 8px; border-radius: 4px; overflow: hidden; }
    .bar-fill { height: 100%; transition: width 0.3s; }
    
    @keyframes pulsePath { 0% { transform: scale(1); } 50% { transform: scale(1.2); } 100% { transform: scale(1); } }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

  </style>

  <!-- Scripts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>

<div class="container">

  <!-- LEFT COLUMN: Grid & Controls -->
  <div class="card" style="flex:1; overflow:hidden;">
    <div style="display:flex; align-items:center; gap:15px; margin-bottom:15px;">
      <div style="width:40px; height:40px; background:linear-gradient(135deg, var(--tn-blue), var(--tn-cyan)); border-radius:10px; display:flex; align-items:center; justify-content:center; color:#000; font-weight:800;">A*</div>
      <div>
        <h1>Pathfinding A*</h1>
        <div style="color:var(--tn-comment); font-size:0.85rem;">Algorithme de recherche de chemin optimal</div>
      </div>
    </div>

    <!-- Controls Toolbar -->
    <div style="display:flex; flex-wrap:wrap; gap:10px; margin-bottom:15px; align-items:center;">
      <button class="btn" id="btn-play">▶ Play</button>
      <button class="btn secondary" id="btn-step">Pas-à-pas</button>
      <button class="btn secondary" id="btn-reset">Reset</button>
      
      <div style="width:1px; height:24px; background:var(--tn-border); margin:0 5px;"></div>
      
      <select id="heuristic-select" class="btn secondary" style="padding:8px;">
        <option value="manhattan">Manhattan (4 dir)</option>
        <option value="euclidean">Euclidienne (8 dir)</option>
        <option value="octile">Octile (8 dir + coût diag)</option>
      </select>
    </div>

    <!-- Main Grid -->
    <div class="grid-container">
      <div id="grid" class="grid"></div>
    </div>

    <!-- Legend -->
    <div style="display:flex; gap:15px; margin-top:15px; font-size:0.85rem; color:var(--tn-comment); flex-wrap:wrap;">
      <div style="display:flex; align-items:center; gap:5px;"><div style="width:12px; height:12px; background:var(--tn-blue); border-radius:2px;"></div> Départ</div>
      <div style="display:flex; align-items:center; gap:5px;"><div style="width:12px; height:12px; background:var(--tn-green); border-radius:2px;"></div> Arrivée</div>
      <div style="display:flex; align-items:center; gap:5px;"><div style="width:12px; height:12px; background:var(--tn-border); border-radius:2px;"></div> Mur (Clic)</div>
      <div style="display:flex; align-items:center; gap:5px;"><div style="width:12px; height:12px; background:var(--tn-orange); opacity:0.5; border-radius:2px;"></div> Open</div>
      <div style="display:flex; align-items:center; gap:5px;"><div style="width:12px; height:12px; background:var(--tn-blue); opacity:0.2; border-radius:2px;"></div> Closed</div>
      <div style="display:flex; align-items:center; gap:5px;"><div style="width:12px; height:12px; background:var(--tn-magenta); border-radius:2px;"></div> Chemin</div>
    </div>
    <div style="font-size:0.8rem; color:var(--tn-comment); margin-top:5px;">
      Ctrl+Clic pour déplacer Départ. Shift+Clic pour déplacer Arrivée.
    </div>
  </div>

  <!-- RIGHT COLUMN: Tabs (Sim, Code, Maths) -->
  <div class="card">
    <div class="nav-tabs">
      <button class="tab-btn active" onclick="switchTab('sim')">Simulation</button>
      <button class="tab-btn" onclick="switchTab('code')">Code Python</button>
      <button class="tab-btn" onclick="switchTab('math')">Théorie</button>
    </div>

    <!-- TAB 1: SIMULATION STATUS -->
    <div id="tab-sim" class="slide active">
      <h2>État Actuel</h2>
      <div style="background:var(--tn-bg-2); padding:15px; border-radius:8px; border-left:3px solid var(--tn-blue); margin-bottom:20px;">
        <div id="status-text" style="color:var(--tn-white);">Prêt. Cliquez sur Play ou Step.</div>
      </div>

      <h2>Analyse du Nœud en cours</h2>
      <p style="font-size:0.85rem; color:var(--tn-comment);">Coûts du nœud sélectionné par l'algorithme :</p>
      
      <div class="bar-row">
        <span style="color:var(--tn-green)">g(n)</span>
        <div class="bar-bg"><div id="bar-g" class="bar-fill" style="width:0%; background:var(--tn-green);"></div></div>
        <span id="val-g" style="color:var(--tn-green)">0</span>
      </div>
      <div class="bar-row">
        <span style="color:var(--tn-yellow)">h(n)</span>
        <div class="bar-bg"><div id="bar-h" class="bar-fill" style="width:0%; background:var(--tn-yellow);"></div></div>
        <span id="val-h" style="color:var(--tn-yellow)">0</span>
      </div>
      <div class="bar-row" style="border-top:1px solid var(--tn-border); padding-top:5px;">
        <span style="color:var(--tn-white); font-weight:bold;">f(n)</span>
        <div class="bar-bg"><div id="bar-f" class="bar-fill" style="width:0%; background:var(--tn-white);"></div></div>
        <span id="val-f" style="color:var(--tn-white); font-weight:bold;">0</span>
      </div>

      <h2 style="margin-top:20px;">Logs</h2>
      <div id="logs" style="font-family:'JetBrains Mono', monospace; font-size:0.75rem; color:var(--tn-comment); height:150px; overflow-y:auto; background:var(--tn-bg-2); padding:10px; border-radius:6px;">
        [System] Initialisé.
      </div>
    </div>

    <!-- TAB 2: CODE PYTHON -->
    <div id="tab-code" class="slide">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
        <h2 style="margin:0;">Implémentation</h2>
        <span style="font-size:0.7rem; color:var(--tn-comment);">Survolez les mots-clés</span>
      </div>
      
      <pre class="line-numbers"><code id="python-code" class="language-python">import heapq
import math

# -------------------------
#     HEURISTIQUES
# -------------------------

def manhattan(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def euclidean(a, b):
    return math.sqrt((a[0] - b[0])**2 + (a[1] - b[1])**2)

def octile(a, b):
    dx = abs(a[0] - b[0])
    dy = abs(a[1] - b[1])
    return (math.sqrt(2) - 1) * min(dx, dy) + max(dx, dy)

# -------------------------
#     VOISINS
# -------------------------

def neighbors(grid, node, allow_diag=True, no_corner_cut=True):
    x, y = node
    
    dirs4 = [(1,0), (-1,0), (0,1), (0,-1)]
    dirs8 = dirs4 + [(1,1), (1,-1), (-1,1), (-1,-1)]
    
    dirs = dirs8 if allow_diag else dirs4

    for dx, dy in dirs:
        nx, ny = x + dx, y + dy
        
        # hors limite
        if not (0 <= nx < len(grid) and 0 <= ny < len(grid[0])):
            continue
        
        # mur ?
        if grid[nx][ny] == 1:
            continue
        
        # empêcher la diagonale entre 2 murs
        if allow_diag and no_corner_cut and dx != 0 and dy != 0:
            if grid[x][ny] == 1 or grid[nx][y] == 1:
                continue
        
        # coût du mouvement
        cost = math.sqrt(2) if (dx != 0 and dy != 0) else 1
        
        yield ( (nx, ny), cost )

# -------------------------
#  RECONSTRUCTION CHEMIN
# -------------------------

def reconstruct_path(came_from, current):
    path = [current]
    while current in came_from:
        current = came_from[current]
        path.append(current)
    return path[::-1]

# -------------------------
#          A*
# -------------------------

def a_star(grid, start, goal, heuristic, allow_diag=True, no_corner_cut=True):
    open_set = []
    heapq.heappush(open_set, (0, start))

    came_from = {}
    g_score = {start: 0}
    closed = set()

    while open_set:
        _, current = heapq.heappop(open_set)
        
        if current == goal:
            return reconstruct_path(came_from, current)

        if current in closed:
            continue
        
        closed.add(current)

        for neighbor, cost in neighbors(grid, current, allow_diag, no_corner_cut):
            tentative_g = g_score[current] + cost

            if neighbor not in g_score or tentative_g < g_score[neighbor]:
                came_from[neighbor] = current
                g_score[neighbor] = tentative_g
                f = tentative_g + heuristic(neighbor, goal)
                heapq.heappush(open_set, (f, neighbor))

    return None

# -------------------------
#        EXEMPLE
# -------------------------

grid = [
    [0,0,0,0],
    [0,1,1,0],
    [0,0,1,0],
    [0,0,0,0],
]

start = (0,0)
goal  = (3,3)

# Autorise les diagonales + autorise le passage diagonal même si murs
path = a_star(grid, start, goal, octile, allow_diag=True, no_corner_cut=False)

print("Chemin trouvé :", path)</code></pre>
    </div>

    <!-- TAB 3: MATH THEORY -->
    <div id="tab-math" class="slide">
      <h2>La Formule A*</h2>
      <div style="background:var(--tn-storm); padding:15px; border-radius:8px; text-align:center; margin-bottom:15px; font-size:1.2rem; color:var(--tn-cyan);">
        $$ f(n) = g(n) + h(n) $$
      </div>
      
      <p>L'algorithme évalue chaque nœud $n$ en combinant deux informations :</p>
      
      <ul style="list-style:none; padding:0; margin-top:15px;">
        <li style="margin-bottom:15px; border-left:3px solid var(--tn-green); padding-left:10px;">
          <strong style="color:var(--tn-green); display:block;">$g(n)$ : Le Coût Réel</strong>
          Somme des coûts depuis le départ.
          <div style="margin-top:5px; background:var(--tn-bg-2); padding:8px; border-radius:4px;">
            $$ g(n) = \sum_{i=0}^{k-1} \text{cost}(p_i, p_{i+1}) $$
            <div style="font-size:0.75rem; color:var(--tn-comment); margin-top:4px;">Avec $p_0 = \text{Start}$ et $p_k = n$.</div>
          </div>
        </li>
        
        <li style="margin-bottom:15px; border-left:3px solid var(--tn-yellow); padding-left:10px;">
          <strong style="color:var(--tn-yellow); display:block;">$h(n)$ : L'Heuristique</strong>
          Estimation de la distance restante.
          
          <div style="margin-top:8px;">
            <div style="font-weight:bold; color:var(--tn-magenta); font-size:0.85rem;">1. Manhattan (4 directions)</div>
            <div style="background:var(--tn-bg-2); padding:6px; border-radius:4px; margin-bottom:8px;">
               $$ h(n) = |n.x - \text{goal}.x| + |n.y - \text{goal}.y| $$
            </div>

            <div style="font-weight:bold; color:var(--tn-magenta); font-size:0.85rem;">2. Euclidienne (Vol d'oiseau)</div>
            <div style="background:var(--tn-bg-2); padding:6px; border-radius:4px; margin-bottom:8px;">
               $$ h(n) = \sqrt{(n.x - \text{goal}.x)^2 + (n.y - \text{goal}.y)^2} $$
            </div>

            <div style="font-weight:bold; color:var(--tn-magenta); font-size:0.85rem;">3. Octile (8 directions)</div>
            <div style="background:var(--tn-bg-2); padding:6px; border-radius:4px;">
               $$ h(n) = (\sqrt{2}-1) \min(\Delta x, \Delta y) + \max(\Delta x, \Delta y) $$
               <div style="font-size:0.7rem; color:var(--tn-comment); margin-top:2px;">Où $\Delta x, \Delta y$ sont les distances absolues.</div>
            </div>
          </div>
        </li>
      </ul>
    </div>

  </div>
</div>

<!-- Popover -->
<div id="popover" class="popover-panel">
  <div id="pop-title" class="popover-title">Titre</div>
  <div id="pop-desc" class="popover-body">Desc</div>
</div>

<script>
/* ========================
   A* LOGIC & STATE
   ======================== */
const ROWS = 15;
const COLS = 15;
const STATE = {
  grid: [],
  start: {r: 2, c: 2},
  goal: {r: 12, c: 12},
  openSet: [],
  closedSet: new Set(),
  cameFrom: {},
  gScore: {},
  fScore: {},
  running: false,
  finished: false,
  path: []
};

function initGrid() {
  const gridEl = document.getElementById('grid');
  gridEl.style.gridTemplateColumns = `repeat(${COLS}, 1fr)`;
  gridEl.innerHTML = '';
  
  STATE.grid = [];
  for(let r=0; r<ROWS; r++) {
    const row = [];
    for(let c=0; c<COLS; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.r = r;
      cell.dataset.c = c;
      cell.onclick = (e) => handleCellClick(r, c, e);
      
      // Values display
      cell.innerHTML = `
        <span class="val-f"></span>
        <span class="val-g"></span>
        <span class="val-h"></span>
      `;
      
      gridEl.appendChild(cell);
      row.push({ wall: false, el: cell });
    }
    STATE.grid.push(row);
  }
  updateGridVisuals();
}

function handleCellClick(r, c, e) {
  if (STATE.running) return;
  
  if (e.ctrlKey) { // Move Start
    STATE.start = {r, c};
  } else if (e.shiftKey) { // Move Goal
    STATE.goal = {r, c};
  } else { // Toggle Wall
    // Don't overwrite start/goal
    if ((r===STATE.start.r && c===STATE.start.c) || (r===STATE.goal.r && c===STATE.goal.c)) return;
    STATE.grid[r][c].wall = !STATE.grid[r][c].wall;
  }
  resetAlgo(); // Reset logic visuals
  updateGridVisuals();
}

function updateGridVisuals() {
  for(let r=0; r<ROWS; r++) {
    for(let c=0; c<COLS; c++) {
      const cellData = STATE.grid[r][c];
      const el = cellData.el;
      
      // Reset classes except basic
      el.className = 'cell';
      
      // Logic classes
      if (cellData.wall) el.classList.add('wall');
      if (r===STATE.start.r && c===STATE.start.c) el.classList.add('start');
      else if (r===STATE.goal.r && c===STATE.goal.c) el.classList.add('goal');
      
      // Algo visuals
      const key = `${r},${c}`;
      if (STATE.path.includes(key)) el.classList.add('path');
      else if (STATE.openSet.find(i => i.key === key)) el.classList.add('open');
      else if (STATE.closedSet.has(key)) el.classList.add('closed');
      
      // Values
      const fSpan = el.querySelector('.val-f');
      const gSpan = el.querySelector('.val-g');
      const hSpan = el.querySelector('.val-h');
      
      if (STATE.fScore[key] !== undefined && !cellData.wall) {
        // Only show details if open/closed or path
        if (el.classList.contains('open') || el.classList.contains('closed') || el.classList.contains('path')) {
           fSpan.textContent = Math.round(STATE.fScore[key]);
           gSpan.textContent = Math.round(STATE.gScore[key]);
           // h is mostly constant per cell but let's not clutter unless computed
        } else {
           fSpan.textContent = ''; gSpan.textContent = '';
        }
      } else {
        fSpan.textContent = ''; gSpan.textContent = ''; hSpan.textContent = '';
      }
    }
  }
}

function resetAlgo() {
  STATE.openSet = [];
  STATE.closedSet = new Set();
  STATE.cameFrom = {};
  STATE.gScore = {};
  STATE.fScore = {};
  STATE.path = [];
  STATE.running = false;
  STATE.finished = false;
  
  // Init Start
  const startKey = `${STATE.start.r},${STATE.start.c}`;
  STATE.gScore[startKey] = 0;
  STATE.fScore[startKey] = heuristic(STATE.start, STATE.goal);
  STATE.openSet.push({ 
    f: STATE.fScore[startKey], 
    r: STATE.start.r, 
    c: STATE.start.c, 
    key: startKey 
  });
  
  log("Réinitialisé.");
  updateGridVisuals();
  updateStats(0, 0, 0);
}

/* ========================
   ALGORITHM STEP
   ======================== */
function step() {
  if (STATE.finished || STATE.openSet.length === 0) {
    if (!STATE.finished) {
       log("Pas de chemin possible !");
       STATE.running = false;
    }
    return;
  }
  
  // Sort openSet by f (mimic priority queue)
  STATE.openSet.sort((a, b) => a.f - b.f);
  
  // Pop lowest f
  const current = STATE.openSet.shift();
  const currentKey = current.key;
  
  // Stats update
  const gCur = STATE.gScore[currentKey];
  const hCur = current.f - gCur;
  updateStats(current.f, gCur, hCur);
  
  if (current.r === STATE.goal.r && current.c === STATE.goal.c) {
    log("Arrivée atteinte ! Reconstruction...");
    reconstructPath();
    STATE.finished = true;
    STATE.running = false;
    updateGridVisuals();
    return;
  }
  
  STATE.closedSet.add(currentKey);
  
  // Neighbors
  const neighbors = getNeighbors(current.r, current.c);
  for (let n of neighbors) {
    const nKey = `${n.r},${n.c}`;
    if (STATE.closedSet.has(nKey)) continue;
    
    // Dist = 1 for orthogonal, 1.414 for diag
    const dist = (n.r === current.r || n.c === current.c) ? 10 : 14; 
    const tentative_g = STATE.gScore[currentKey] + dist;
    
    // Check if better path
    if (tentative_g < (STATE.gScore[nKey] || Infinity)) {
      STATE.cameFrom[nKey] = currentKey;
      STATE.gScore[nKey] = tentative_g;
      STATE.fScore[nKey] = tentative_g + heuristic(n, STATE.goal);
      
      if (!STATE.openSet.find(x => x.key === nKey)) {
        STATE.openSet.push({
          f: STATE.fScore[nKey],
          r: n.r, c: n.c, key: nKey
        });
      }
    }
  }
  
  updateGridVisuals();
}

function getNeighbors(r, c) {
  const mode = document.getElementById('heuristic-select').value;
  const neighbors = [];
  const dirs = [
    {dr:0, dc:1}, {dr:0, dc:-1}, {dr:1, dc:0}, {dr:-1, dc:0} // Ortho
  ];
  
  if (mode !== 'manhattan') {
    dirs.push({dr:1, dc:1}, {dr:1, dc:-1}, {dr:-1, dc:1}, {dr:-1, dc:-1}); // Diag
  }
  
  for(let d of dirs) {
    const nr = r + d.dr;
    const nc = c + d.dc;
    
    if (nr >= 0 && nr < ROWS && nc >= 0 && nc < COLS) {
      if (!STATE.grid[nr][nc].wall) {
        neighbors.push({r: nr, c: nc});
      }
    }
  }
  return neighbors;
}

function heuristic(a, b) {
  const mode = document.getElementById('heuristic-select').value;
  const dr = Math.abs(a.r - b.r);
  const dc = Math.abs(a.c - b.c);
  
  if (mode === 'manhattan') return (dr + dc) * 10;
  if (mode === 'euclidean') return Math.sqrt(dr*dr + dc*dc) * 10;
  // Octile
  return (10 * (dr + dc) + (14 - 2 * 10) * Math.min(dr, dc));
}

function reconstructPath() {
  let curr = `${STATE.goal.r},${STATE.goal.c}`;
  STATE.path = [];
  while(STATE.cameFrom[curr]) {
    STATE.path.push(curr);
    curr = STATE.cameFrom[curr];
  }
  STATE.path.push(`${STATE.start.r},${STATE.start.c}`);
}

/* ========================
   UI & INTERACTION
   ======================== */
function updateStats(f, g, h) {
  // Normalize visuals a bit (assuming max path ~ 200)
  const maxVal = 200; 
  document.getElementById('val-f').innerText = Math.round(f);
  document.getElementById('bar-f').style.width = Math.min(100, (f/maxVal)*100) + "%";
  
  document.getElementById('val-g').innerText = Math.round(g);
  document.getElementById('bar-g').style.width = Math.min(100, (g/maxVal)*100) + "%";
  
  document.getElementById('val-h').innerText = Math.round(h);
  document.getElementById('bar-h').style.width = Math.min(100, (h/maxVal)*100) + "%";
}

function log(msg) {
  const box = document.getElementById('logs');
  box.innerHTML = `> ${msg}<br>` + box.innerHTML;
}

function switchTab(id) {
  document.querySelectorAll('.slide').forEach(s => s.classList.remove('active'));
  document.getElementById('tab-' + id).classList.add('active');
  document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
  event.target.classList.add('active');
}

// Button Events
let interval = null;

document.getElementById('btn-play').onclick = () => {
  if (STATE.finished) resetAlgo();
  STATE.running = true;
  if (interval) clearInterval(interval);
  interval = setInterval(step, 100); // 100ms per step
  log("Lecture automatique...");
};

document.getElementById('btn-step').onclick = () => {
  if (interval) clearInterval(interval);
  if (STATE.finished) return;
  STATE.running = false;
  step();
  log("Étape manuelle.");
};

document.getElementById('btn-reset').onclick = () => {
  if (interval) clearInterval(interval);
  resetAlgo();
};

document.getElementById('heuristic-select').onchange = () => {
  if (interval) clearInterval(interval);
  resetAlgo();
  log("Heuristique changée.");
};


/* ========================
   POPOVERS & HIGHLIGHTS
   ======================== */
const definitions = {
  'heapq': { title:'heapq', text:'Module Python pour gérer les files de priorité (tas binaire).' },
  'heappush': { title:'heappush', text:'Ajoute un élément en gardant l\'ordre du tas.' },
  'heappop': { title:'heappop', text:'Retire et renvoie le plus petit élément du tas.' },
  'def': { title:'def', text:'Déclare une fonction.' },
  'return': { title:'return', text:'Renvoie une valeur et quitte la fonction.' },
  'open_set': { title:'Open Set', text:'Liste des nœuds découverts mais pas encore évalués.' },
  'g_score': { title:'g_score', text:'Coût réel du départ jusqu\'au nœud actuel.' },
  'while': { title:'while', text:'Boucle tant que la condition est vraie.' },
  'manhattan': { title:'Manhattan', text:'Distance en "taxi" : |dx| + |dy|.' },
  'euclidean': { title:'Euclidienne', text:'Distance à vol d\'oiseau : sqrt(dx² + dy²).' },
  'octile': { title:'Octile', text:'Distance optimisée pour les déplacements diagonaux.' },
  'a_star': { title:'A*', text:'Algorithme principal combinant g_score et heuristique.' },
  'reconstruct_path': { title:'Reconstruction', text:'Remonte les parents depuis l\'arrivée pour tracer le chemin.' },
  'neighbors': { title:'Voisins', text:'Génère les cases adjacentes valides (non-mur).' }
};

window.addEventListener('load', () => {
  initGrid();
  resetAlgo();
  
  // Syntax Highlighting Popovers
  Prism.highlightAll();
  setTimeout(() => {
    const codeBlock = document.getElementById('python-code');
    const tokens = codeBlock.querySelectorAll('.token');
    
    tokens.forEach(token => {
      const text = token.textContent.trim();
      // Simple heuristic mapping
      let key = text; 
      if (text === 'open_set') key = 'open_set'; 
      if (text === 'g_score') key = 'g_score'; 
      
      if (definitions[key]) {
        token.classList.add('clickable');
        token.addEventListener('mouseenter', (e) => showPopover(e, definitions[key]));
        token.addEventListener('mousemove', movePopover);
        token.addEventListener('mouseleave', hidePopover);
      }
    });
  }, 500);
});

const popover = document.getElementById('popover');
const popTitle = document.getElementById('pop-title');
const popDesc = document.getElementById('pop-desc');

function showPopover(e, def) {
  popTitle.textContent = def.title;
  popDesc.textContent = def.text;
  popover.classList.add('popover-visible');
  movePopover(e);
}

function movePopover(e) {
  const offset = 15;
  let left = e.clientX + offset;
  let top = e.clientY + offset;
  if (left + 300 > window.innerWidth) left = e.clientX - 310;
  popover.style.left = left + 'px';
  popover.style.top = top + 'px';
}

function hidePopover() {
  popover.classList.remove('popover-visible');
}

</script>
</body>
</html>
