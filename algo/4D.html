<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Atelier 4D — PINKARIUM</title>
    
    <!-- Favicon -->
    <link rel="icon" href="https://pinkara.github.io/PINKARIUM/favicon/favicon.ico" sizes="any">
    <link rel="icon" type="image/png" href="https://pinkara.github.io/PINKARIUM/favicon/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="https://pinkara.github.io/PINKARIUM/favicon/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://pinkara.github.io/PINKARIUM/favicon/favicon-48x48.png" sizes="48x48">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="icon" type="image/png" href="https://pinkara.github.io/PINKARIUM/favicon/android-chrome-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="https://pinkara.github.io/PINKARIUM/favicon/android-chrome-512x512.png" sizes="512x512">
    <link rel="apple-touch-icon" href="https://pinkara.github.io/PINKARIUM/favicon/apple-touch-icon.png">
    <link rel="mask-icon" href="https://pinkara.github.io/PINKARIUM/favicon/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="icon" href="https://pinkara.github.io/PINKARIUM/favicon/favicon.svg" type="image/svg+xml">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        /* TOKYO NIGHT THEME */
        :root {
            --tn-bg: #1a1b26; --tn-bg-2: #24283b; --tn-fg: #c0caf5; 
            --tn-accent: #7aa2f7; --tn-cyan: #7dcfff; --tn-green: #9ece6a;
            --tn-orange: #ff9e64; --tn-magenta: #bb9af7; --tn-red: #f7768e;
            --tn-border: #414868; --tn-comment: #565f89; --tn-logo: #1abc9c;
        }

        body {
            background-color: var(--tn-bg); color: var(--tn-fg);
            font-family: 'Inter', sans-serif; margin: 0;
            display: flex; height: 100vh; width: 100vw; overflow: hidden;
        }

        .app-container { display: flex; width: 100%; height: 100%; }
        .canvas-area {
            flex: 1; position: relative; background: #16161e; 
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            overflow: hidden; border-right: 1px solid var(--tn-border); cursor: grab;
        }
        .canvas-area:active { cursor: grabbing; }
        canvas { display: block; width: 100%; height: 100%; }

        .sidebar {
            width: 420px; background: var(--tn-bg-2); display: flex; flex-direction: column;
            overflow: hidden; box-shadow: -5px 0 20px rgba(0,0,0,0.3); z-index: 10; flex-shrink: 0;
        }

        .header-box {
            padding: 16px; border-bottom: 1px solid var(--tn-border);
            background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
        }
        .logo-box {
            width: 40px; height: 40px; 
            background: linear-gradient(135deg, var(--tn-logo), var(--tn-accent)); 
            border-radius: 8px; 
            display: flex; align-items: center; justify-content: center; 
            font-weight: 800; color: #1a1b26; font-size: 1.2rem;
            box-shadow: 0 4px 12px #1abc9c4d;
        }

        h1 { color: var(--tn-fg); font-weight: 800; font-size: 1.1rem; margin: 0; }
        .subtitle { color: var(--tn-cyan); font-size: 0.75rem; font-weight: 500; opacity: 0.9; margin-top:2px; }

        .tabs { display: flex; background: rgba(0,0,0,0.2); gap: 1px; }
        .tab-btn {
            flex: 1; padding: 12px; background: var(--tn-bg-2); border: none;
            border-bottom: 2px solid transparent; color: var(--tn-comment);
            cursor: pointer; font-weight: 600; font-size: 0.85rem; transition: all 0.2s;
        }
        .tab-btn:hover { color: var(--tn-fg); background: rgba(255,255,255,0.02); }
        .tab-btn.active { color: var(--tn-magenta); border-bottom-color: var(--tn-magenta); background: rgba(187, 154, 247, 0.05); }

        .content-scroll { flex: 1; overflow-y: auto; padding: 16px; }
        .panel { display: none; animation: fadeIn 0.3s ease; }
        .panel.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        .control-group {
            background: rgba(0,0,0,0.2); border: 1px solid var(--tn-border);
            padding: 14px; border-radius: 8px; margin-bottom: 14px;
        }
        .control-header {
            font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px;
            color: var(--tn-accent); margin-bottom: 12px; font-weight: 700; display: flex; justify-content: space-between;
        }
        .sub-header {
            font-size: 0.7rem; color: var(--tn-magenta); font-weight: 600; margin-top: 12px; margin-bottom: 4px;
            border-bottom: 1px dashed var(--tn-border); padding-bottom: 2px;
        }

        label { display: block; font-size: 0.8rem; margin-bottom: 6px; color: var(--tn-fg); margin-top: 10px; }
        .val-display { float: right; font-family: 'JetBrains Mono'; font-size: 0.75rem; color: var(--tn-cyan); }

        select, input[type="text"] {
            width: 100%; background: #141621; border: 1px solid var(--tn-border);
            color: var(--tn-fg); padding: 8px; border-radius: 4px; font-size: 0.8rem; outline: none;
            font-family: 'JetBrains Mono', monospace; cursor: pointer;
        }
        input[type="range"] {
            width: 100%; accent-color: var(--tn-magenta); height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer; margin-top: 6px;
        }
        input[type="color"] { width: 100%; height: 32px; border: none; background: transparent; cursor: pointer; border-radius: 4px; }
        
        .chk-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; font-size: 0.85rem; padding: 4px 0; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .chk-row:last-child { border-bottom: none; }
        input[type="checkbox"] { accent-color: var(--tn-green); transform: scale(1.2); cursor: pointer; }

        .canvas-overlay {
            position: absolute; bottom: 20px; left: 20px;
            background: rgba(26, 27, 38, 0.85); backdrop-filter: blur(4px);
            padding: 12px 16px; border-radius: 6px; border: 1px solid var(--tn-border);
            pointer-events: none; font-size: 0.75rem; color: var(--tn-comment);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .key { color: var(--tn-magenta); font-weight: bold; font-family: 'JetBrains Mono'; background: rgba(255,255,255,0.1); padding: 2px 5px; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); }
        .key.active { background: var(--tn-orange); color: #000; border-color: var(--tn-orange); }
        
        .warning-text { font-size: 0.7rem; color: var(--tn-red); margin-top: 4px; font-style: italic; display: none; }
        .warning-text.show { display: block; }

        @media (max-width: 900px) {
            .app-container { flex-direction: column; }
            .sidebar { width: 100%; height: 50%; order: 2; }
            .canvas-area { height: 50%; border-right: none; border-bottom: 1px solid var(--tn-border); order: 1; }
        }
    </style>
</head>
<body>

<div class="app-container">
  
  <div class="canvas-area">
    <canvas id="glCanvas"></canvas>
    <div class="canvas-overlay">
        <div style="margin-bottom:6px; color:var(--tn-fg); font-weight:bold; letter-spacing:0.5px;">MODES D'INTERACTION</div>
        <div style="line-height: 1.8;">
            <span class="key" id="badgeShift">SHIFT</span> + <span class="key">Drag</span> : Rotation 3D (X/Y)<br>
            <span class="key" id="badgeCtrl">CTRL</span> + <span class="key">Drag</span> : Rotation 4D (Plans XW/YW)<br>
            <span class="key" id="badgeCtrlWheel">CTRL</span> + <span class="key">Molette</span> : Déplacement Ana/Kata (W)<br>
            <span class="key">R</span> : Réinitialiser Position
        </div>
    </div>
  </div>

  <div class="sidebar">
    <div class="header-box">
      <div style="display: flex; gap: 12px; align-items: center;">
        <div class="logo-box">4D</div>
        <div>
          <h1>Atelier - 4D</h1>
          <div class="subtitle">Ana & Kata • Rotations & Translations</div>
        </div>
      </div>
    </div>
    
    <div class="tabs">
      <button class="tab-btn active" onclick="setTab('lab')">Laboratoire</button>
      <button class="tab-btn" onclick="setTab('theory')">Théorie</button>
    </div>

    <div class="content-scroll">
      
      <!-- ONGLET LABO -->
      <div id="panel-lab" class="panel active">
        
        <!-- GEOMETRY -->
        <div class="control-group">
            <div class="control-header">GÉOMÉTRIE & PROJECTION</div>
            <label>Objet</label>
            <select id="shapeSelect">
                <option value="tesseract">Tesseract (Hypercube)</option>
                <option value="cube">Cube</option>
                <option value="glome">Glome (Hypersphère)</option>
                <option value="toroid">Toroïde de Clifford</option>
                <option value="16cell">16-Cellules (Orthoplex)</option>
                <option value="pentachoron">Pentachoron (Simplex)</option>
                <option value="cylinder">cylindre</option>
                <option value="oloid3D">Oloïde</option>
            </select>

            <label>Zoom Global</label>
            <input type="range" id="scaleInput" min="50" max="1000" value="250">
        </div>

        <!-- TRANSLATION W (ANA / KATA) -->
        <div class="control-group" style="border-left: 3px solid var(--tn-orange);">
            <div class="control-header" style="color:var(--tn-orange)">DÉPLACEMENT INFINI (W)</div>
            <p style="font-size:0.75rem; color:var(--tn-comment); margin-bottom:8px;">
                Déplace l'objet le long de l'axe W. Aucune limite.
            </p>

            <label style="display:flex; justify-content:space-between;">
                <span>Position W (Ana/Kata)</span>
                <span id="val-transW" class="val-display">0.00</span>
            </label>
            <!-- Plage du slider élargie -->
            <input type="range" id="transWInput" min="-5" max="5" step="0.01" value="0.00">
            <div class="warning-text" id="w-warning">Objet hors champ (Singularité ou inversion)</div>
            
            <div style="display:flex; justify-content:space-between; font-size:0.7rem; color:var(--tn-comment); margin-top:2px;">
                <span>← KATA (Infini)</span>
                <span>ANA (Infini) →</span>
            </div>
        </div>

        <!-- AUTO ROTATION 4D -->
        <div class="control-group" style="border-left: 3px solid var(--tn-magenta);">
            <div class="control-header" style="color:var(--tn-magenta)">AUTO-ROTATION 4D</div>
            
            <div class="sub-header">PLAN X-W</div>
            <label style="display:flex; justify-content:space-between;">
                <span>Vitesse</span>
                <span id="val-rotXW" class="val-display">0.005</span>
            </label>
            <input type="range" id="autoRotXW" min="-0.05" max="0.05" step="0.001" value="0.005">

            <div class="sub-header">PLAN Z-W</div>
            <label style="display:flex; justify-content:space-between;">
                <span>Vitesse</span>
                <span id="val-rotZW" class="val-display">0.000</span>
            </label>
            <input type="range" id="autoRotZW" min="-0.05" max="0.05" step="0.001" value="0.000">
            
            <div style="margin-top: 14px; padding-top:10px; border-top:1px solid rgba(255,255,255,0.05)">
                <button id="resetBtn" style="width:100%; padding:8px; background:rgba(247, 118, 142, 0.1); border:1px solid var(--tn-red); color:var(--tn-red); border-radius:4px; cursor:pointer; font-weight:bold; font-size:0.8rem; transition:0.2s">ARRÊT & RESET</button>
            </div>
        </div>

        <!-- STYLE (COMPLET) -->
        <div class="control-group">
            <div class="control-header">RENDU & STYLE</div>
            
            <div class="chk-row">
                <span>Afficher Arêtes</span>
                <input type="checkbox" id="chkEdges" checked>
            </div>
            <div class="chk-row">
                <span>Afficher Faces</span>
                <input type="checkbox" id="chkFaces" checked>
            </div>
            <div class="chk-row">
                <span>Afficher Points</span>
                <input type="checkbox" id="chkPoints">
            </div>

            <label>Couleur Principale</label>
            <input type="color" id="neonColor" value="#7aa2f7">

            <label style="display:flex; justify-content:space-between;">
                <span>Opacité Faces</span>
                <span id="val-alpha" class="val-display">0.10</span>
            </label>
            <input type="range" id="faceAlpha" min="0.0" max="0.8" step="0.01" value="0.10">
        </div>

      </div>
      
      <!-- ONGLET THÉORIE -->
      <div id="panel-theory" class="panel">
        <h2 class="text-lg font-bold mb-4" style="color:var(--tn-fg)">L'Axe W Infini</h2>
        <p class="text-sm mb-4" style="color:var(--tn-comment);">
            En 4D, se déplacer "Ana" ou "Kata" change votre distance relative à l'observateur dans la quatrième dimension. C'est analogue à un objet 3D qui s'éloigne ou se rapproche d'une caméra.
        </p>
        <p class="text-sm mb-4" style="color:var(--tn-comment);">
            L'inversion observée lorsque vous "dépassez" la caméra est mathématiquement correcte : c'est le même effet que lorsqu'un objet passe derrière vos yeux en 3D, mais projeté depuis la 4D.
        </p>
      </div>

    </div>
  </div>
</div>

<script>
/**
 * --- MOTEUR 4D ---
 */

class Vec4 {
    constructor(x, y, z, w) { this.x = x; this.y = y; this.z = z; this.w = w; }
    
    // Projection Stéréographique 4D -> 3D
    project(wDist, wTranslation, scale) {
        let wPos = this.w + wTranslation;
        let dist = wDist;
        let denominator = dist - wPos;
        
        // Gestion de la singularité (division par zéro) 
        if (Math.abs(denominator) < 0.0001) denominator = 0.0001;
        
        let factor = 1 / denominator;
        
        return {
            x: this.x * factor,
            y: this.y * factor,
            z: this.z * factor,
            scaleFactor: factor // Pour effets visuels
        };
    }
}

class Mat4 {
    static rotXW(t) { const c=Math.cos(t), s=Math.sin(t); return v => new Vec4(v.x*c - v.w*s, v.y, v.z, v.x*s + v.w*c); }
    static rotYW(t) { const c=Math.cos(t), s=Math.sin(t); return v => new Vec4(v.x, v.y*c - v.w*s, v.z, v.y*s + v.w*c); }
    static rotZW(t) { const c=Math.cos(t), s=Math.sin(t); return v => new Vec4(v.x, v.y, v.z*c - v.w*s, v.z*s + v.w*c); }
}

const Shapes = {
    tesseract: () => {
        let vertices = [];
        for(let i=0; i<16; i++) vertices.push(new Vec4((i&1)?1:-1, (i&2)?1:-1, (i&4)?1:-1, (i&8)?1:-1));
        let edges = [];
        for(let i=0; i<16; i++) for(let j=i+1; j<16; j++) { let x = i^j; if ((x & (x-1)) === 0) edges.push([i, j]); }
        let faces = [];
        const powers = [1, 2, 4, 8];
        for (let d1=0; d1<3; d1++) for (let d2=d1+1; d2<4; d2++) {
            let m1 = powers[d1], m2 = powers[d2];
            for (let i=0; i<16; i++) if ((i & (m1|m2)) === 0) faces.push([i, i|m1, i|m1|m2, i|m2]);
        }
        return { vertices, edges, faces }; 
    },
    toroid: () => {
        let vertices = [], faces = [], edges = [];
        const U_RES = 20, V_RES = 20;
        // Vertices
        for(let i=0; i<U_RES; i++) {
            let u = (i/U_RES) * 2 * Math.PI;
            for(let j=0; j<V_RES; j++) {
                let v = (j/V_RES) * 2 * Math.PI;
                vertices.push(new Vec4(Math.cos(u), Math.sin(u), Math.cos(v), Math.sin(v)));
            }
        }
        // Edges and Faces
        for(let i=0; i<U_RES; i++) for(let j=0; j<V_RES; j++) {
            let p1 = i*V_RES + j;
            let p2 = ((i+1)%U_RES)*V_RES + j;
            let p3 = ((i+1)%U_RES)*V_RES + ((j+1)%V_RES); // Added for face
            let p4 = i*V_RES + ((j+1)%V_RES);
            
            edges.push([p1, p2]); edges.push([p1, p4]);
            faces.push([p1, p2, p3, p4]); // NEW: Adding the face quad
        }
        return { vertices, edges, faces };
    },
    pentachoron: () => {
        const r = 1.2, a = 1 / Math.sqrt(10);
        let vertices = [ new Vec4(r, r, r, a), new Vec4(r, -r, -r, a), new Vec4(-r, r, -r, a), new Vec4(-r, -r, r, a), new Vec4(0, 0, 0, -r/Math.sqrt(2.5)) ];
        let edges = []; for(let i=0;i<5;i++) for(let j=i+1;j<5;j++) edges.push([i,j]);
        let faces = [[0,1,2],[0,1,3],[0,1,4],[0,2,3],[0,2,4],[0,3,4],[1,2,3],[1,2,4],[1,3,4],[2,3,4]];
        return {vertices, edges, faces};
    },
    '16cell': () => {
        let vertices = [];
        for(let i=0; i<4; i++) { 
            let v1=[0,0,0,0]; v1[i]=1.5; vertices.push(new Vec4(...v1)); 
            let v2=[0,0,0,0]; v2[i]=-1.5; vertices.push(new Vec4(...v2)); 
        }
        let edges = []; for(let i=0; i<8; i++) for(let j=i+1; j<8; j++) if((i>>1)!==(j>>1)) edges.push([i,j]);
        let faces = []; for(let i=0; i<8; i++) for(let j=i+1; j<8; j++) for(let k=j+1; k<8; k++) 
            if((i>>1)!==(j>>1) && (j>>1)!==(k>>1) && (i>>1)!==(k>>1)) faces.push([i,j,k]);
        return {vertices, edges, faces};
    },
    glome: () => {
        let vertices = [], edges = [], faces = [];
        const latBands = 16, longBands = 16, wBands = 12;
        for (let i = 0; i <= wBands; i++) {
            let theta = (i / wBands) * Math.PI, w = Math.cos(theta), r3d = Math.sin(theta);          
            let startIdx = vertices.length;
            for (let lat = 0; lat <= latBands; lat++) {
                let phi = (lat / latBands) * Math.PI, sinPhi = Math.sin(phi), cosPhi = Math.cos(phi);
                for (let lon = 0; lon <= longBands; lon++) {
                    let psi = (lon / longBands) * 2 * Math.PI;
                    vertices.push(new Vec4(r3d * sinPhi * Math.cos(psi), r3d * cosPhi, r3d * sinPhi * Math.sin(psi), w));
                }
            }
            let ptsPerRow = longBands + 1;
            for (let lat = 0; lat < latBands; lat++) for (let lon = 0; lon < longBands; lon++) {
                let current = startIdx + lat * ptsPerRow + lon, next = current + ptsPerRow;
                faces.push([current, current+1, next+1, next]);
                edges.push([current, current+1]); edges.push([current, next]);
            }
        }
        return { vertices, edges, faces };
    },
    cube: () => {
        let vertices = []; const r = 1.2;
        for(let i=0; i<8; i++) vertices.push(new Vec4((i&1)?r:-r, (i&2)?r:-r, (i&4)?r:-r, 0));
        let edges = [];
        for(let i=0; i<8; i++) for(let j=i+1; j<8; j++) { let x = i^j; if ((x & (x-1)) === 0) edges.push([i, j]); }
        let faces = [[0,1,3,2], [4,5,7,6], [0,1,5,4], [2,3,7,6], [0,2,6,4], [1,3,7,5]];
        return { vertices, edges, faces };
    },
    oloid3D: () => {
    let vertices = [];
    let edges = [];
    let faces = [];
    
    const res = 60; // Résolution pour une courbe lisse
    const r = 1.0;  // Rayon
    const d = r;    // Distance entre les centres (égale au rayon pour l'Oloïde)
    
    // Cercle 1 : Plan Horizontal (XZ), Centre (-d/2, 0, 0)
    // Équation : (x + d/2)^2 + z^2 = r^2
    let offset1 = 0;
    for (let i = 0; i < res; i++) {
        let t = (i / res) * Math.PI * 2;
        vertices.push(new Vec4(-d/2 + Math.cos(t) * r, 0, Math.sin(t) * r, 0));
    }

    // Cercle 2 : Plan Vertical (XY), Centre (d/2, 0, 0)
    // Équation : (x - d/2)^2 + y^2 = r^2
    // Note : On l'oriente pour qu'il soit perpendiculaire au premier
    let offset2 = res;
    for (let i = 0; i < res; i++) {
        let t = (i / res) * Math.PI * 2;
        vertices.push(new Vec4(d/2 + Math.cos(t) * r, Math.sin(t) * r, 0, 0));
    }

    // Génération de l'enveloppe convexe
    // L'Oloïde est une surface réglée reliant les arcs des deux cercles.
    // Une méthode simple pour visualiser le volume est de relier les deux périmètres.
    // (Une triangulation "Convex Hull" précise demanderait un algo plus lourd, 
    // ici on tisse les cercles entre eux).
    for (let i = 0; i < res; i++) {
        let i_next = (i + 1) % res;
        for (let j = 0; j < res; j++) {
            let j_next = (j + 1) % res;
            
            // On ajoute des faces pour créer le volume entre les deux anneaux
            // Astuce visuelle : on peut ne dessiner que si les normales sont cohérentes,
            // mais relier tout le monde crée bien l'enveloppe brute.
            faces.push([i, j + offset2, j_next + offset2, i_next]);
        }
    }
    
    // Arêtes des cercles pour bien voir la structure "squelette"
    for(let i=0; i<res; i++) {
        edges.push([i, (i+1)%res]); // Cercle 1
        edges.push([offset2+i, offset2+(i+1)%res]); // Cercle 2
    }

    return { vertices, edges, faces };
    },
    cylinder: () => {
        let vertices = [], edges = [], faces = [];
        const steps = 32, h = 1.5, r = 1.0;
        for(let s=0; s<2; s++) {
            let y = s===0 ? -h : h;
            for(let i=0; i<steps; i++) vertices.push(new Vec4(r*Math.cos((i/steps)*Math.PI*2), y, r*Math.sin((i/steps)*Math.PI*2), 0));
        }
        for(let i=0; i<steps; i++) {
            let next = (i+1)%steps, b1 = i, b2 = next, t1 = i + steps, t2 = next + steps;
            faces.push([b1, b2, t2, t1]); edges.push([b1, b2]); edges.push([t1, t2]);
            if(i%4 === 0) edges.push([b1, t1]);
        }
        return { vertices, edges, faces };
    },
};

/**
 * --- APP STATE ---
 */
const canvas = document.getElementById('glCanvas');
const ctx = canvas.getContext('2d');
const app = {
    shape: 'tesseract',
    scale: 250,
    wDist: 2.5,
    wTrans: 0.0,
    angles: { x:0, y:0, z:0, xw:0, yw:0, zw:0 },
    auto: { speedXW: 0.005, speedZW: 0.000 },
    style: { edges: true, faces: true, points: false, color: '#7aa2f7', alpha: 0.10 },
    mouse: { down: false, x: 0, y: 0 },
    keys: { shift: false, ctrl: false },
    geometry: null
};

app.geometry = Shapes.tesseract();
resize();

// --- EVENT LISTENERS ---

document.getElementById('shapeSelect').addEventListener('change', e => { 
    app.shape = e.target.value; app.geometry = Shapes[app.shape](); 
});
document.getElementById('scaleInput').addEventListener('input', e => app.scale = parseInt(e.target.value));

const uiTransW = document.getElementById('transWInput');
const warningEl = document.getElementById('w-warning');

function updateW(newVal) {
    app.wTrans = newVal;
    uiTransW.value = app.wTrans;
    document.getElementById('val-transW').innerText = app.wTrans.toFixed(2);
    if (app.wTrans > 2.0 || app.wTrans < -10.0) warningEl.classList.add('show');
    else warningEl.classList.remove('show');
}

uiTransW.addEventListener('input', e => updateW(parseFloat(e.target.value)));

document.getElementById('autoRotXW').addEventListener('input', e => {
    app.auto.speedXW = parseFloat(e.target.value);
    document.getElementById('val-rotXW').innerText = app.auto.speedXW.toFixed(3);
});
document.getElementById('autoRotZW').addEventListener('input', e => {
    app.auto.speedZW = parseFloat(e.target.value);
    document.getElementById('val-rotZW').innerText = app.auto.speedZW.toFixed(3);
});

document.getElementById('resetBtn').addEventListener('click', () => { 
    app.angles = {x:0,y:0,z:0,xw:0,yw:0,zw:0}; 
    updateW(0);
    app.auto.speedXW = 0; document.getElementById('autoRotXW').value = 0; document.getElementById('val-rotXW').innerText = "0.000";
    app.auto.speedZW = 0; document.getElementById('autoRotZW').value = 0; document.getElementById('val-rotZW').innerText = "0.000";
});

// --- STYLE CONTROLS ---
document.getElementById('chkEdges').addEventListener('change', e => app.style.edges = e.target.checked);
document.getElementById('chkFaces').addEventListener('change', e => app.style.faces = e.target.checked);
document.getElementById('chkPoints').addEventListener('change', e => app.style.points = e.target.checked);
document.getElementById('neonColor').addEventListener('input', e => app.style.color = e.target.value);
document.getElementById('faceAlpha').addEventListener('input', e => {
    app.style.alpha = parseFloat(e.target.value);
    document.getElementById('val-alpha').innerText = app.style.alpha.toFixed(2);
});

window.setTab = (id) => {
    document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('panel-'+id).classList.add('active');
    document.querySelector(`.tab-btn[onclick="setTab('${id}')"]`).classList.add('active');
};

window.addEventListener('resize', resize);
function resize() {
    const parent = canvas.parentElement;
    canvas.width = parent.clientWidth;
    canvas.height = parent.clientHeight;
}

// --- CLAVIER & SOURIS ---
window.addEventListener('keydown', e => {
    if(e.key === 'Shift') { app.keys.shift = true; document.getElementById('badgeShift').classList.add('active'); }
    if(e.key === 'Control') { 
        app.keys.ctrl = true; 
        document.getElementById('badgeCtrl').classList.add('active'); 
        document.getElementById('badgeCtrlWheel').classList.add('active'); 
    }
    if(e.key.toLowerCase() === 'r') document.getElementById('resetBtn').click();
});
window.addEventListener('keyup', e => {
    if(e.key === 'Shift') { app.keys.shift = false; document.getElementById('badgeShift').classList.remove('active'); }
    if(e.key === 'Control') { 
        app.keys.ctrl = false; 
        document.getElementById('badgeCtrl').classList.remove('active');
        document.getElementById('badgeCtrlWheel').classList.remove('active');
    }
});
canvas.addEventListener('mousedown', e => { app.mouse.down = true; app.mouse.x = e.clientX; app.mouse.y = e.clientY; });
window.addEventListener('mouseup', () => app.mouse.down = false);

canvas.addEventListener('wheel', e => {
    if(app.keys.ctrl) {
        e.preventDefault();
        const delta = e.deltaY * 0.002;
        updateW(app.wTrans + delta);
    }
}, { passive: false });

canvas.addEventListener('mousemove', e => {
    if (!app.mouse.down) return;
    const dx = (e.clientX - app.mouse.x) * 0.008;
    const dy = (e.clientY - app.mouse.y) * 0.008;
    app.mouse.x = e.clientX; app.mouse.y = e.clientY;

    if (app.keys.ctrl) {
        app.angles.xw += dx; app.angles.yw -= dy; 
    } else if (app.keys.shift) {
        app.angles.y -= dx; app.angles.x += dy;
    } else {
        app.angles.y -= dx; app.angles.x += dy;
    }
});

/**
 * --- RENDER LOOP ---
 */
function hexToRgb(hex) {
    let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : {r:0,g:0,b:0};
}

function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    
    app.angles.xw += app.auto.speedXW;
    app.angles.zw += app.auto.speedZW;

    const rXW = Mat4.rotXW(app.angles.xw);
    const rYW = Mat4.rotYW(app.angles.yw);
    const rZW = Mat4.rotZW(app.angles.zw);
    const cosX = Math.cos(app.angles.x), sinX = Math.sin(app.angles.x);
    const cosY = Math.cos(app.angles.y), sinY = Math.sin(app.angles.y);

    let projectedVerts = app.geometry.vertices.map((v, i) => {
        let p = new Vec4(v.x, v.y, v.z, v.w);
        p = rXW(p); p = rYW(p); p = rZW(p);
        let p3 = p.project(app.wDist, app.wTrans);
        
        let x = p3.x, y = p3.y, z = p3.z;
        let y2 = y * cosX - z * sinX;
        let z2 = y * sinX + z * cosX;
        let x2 = x * cosY - z2 * sinY;
        let z3 = x * sinY + z2 * cosY;
        
        let fov = 4;
        let scale = app.scale;
        let persp = fov / (fov - z3 * 0.2);
        
        return {
            x: cx + x2 * scale * persp,
            y: cy + y2 * scale * persp,
            z: z3,
            wFact: p3.scaleFactor
        };
    });

    let facesToDraw = [];
    if (app.style.faces) {
        for (let f of app.geometry.faces) {
            let zSum = 0;
            for(let idx of f) zSum += projectedVerts[idx].z;
            facesToDraw.push({ indices: f, z: zSum / f.length });
        }
        facesToDraw.sort((a, b) => a.z - b.z);
    }

    const rgb = hexToRgb(app.style.color);
    const baseColorStr = `${rgb.r}, ${rgb.g}, ${rgb.b}`;

    // DRAW FACES
    if (app.style.faces) {
        ctx.lineWidth = 1;
        for (let face of facesToDraw) {
            let v0Factor = Math.abs(projectedVerts[face.indices[0]].wFact);
            let alphaFactor = Math.min(1, v0Factor * 1.5); 
            ctx.fillStyle = `rgba(${baseColorStr}, ${app.style.alpha * alphaFactor})`;
            ctx.strokeStyle = `rgba(${baseColorStr}, ${app.style.alpha * 2 * alphaFactor})`;
            
            ctx.beginPath();
            let v0 = projectedVerts[face.indices[0]];
            ctx.moveTo(v0.x, v0.y);
            for (let j=1; j<face.indices.length; j++) ctx.lineTo(projectedVerts[face.indices[j]].x, projectedVerts[face.indices[j]].y);
            ctx.closePath();
            ctx.fill();
            if(!app.style.edges) ctx.stroke();
        }
    }

    // DRAW EDGES
    if (app.style.edges) {
        ctx.strokeStyle = app.style.color;
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let edge of app.geometry.edges) {
            let p1 = projectedVerts[edge[0]];
            let p2 = projectedVerts[edge[1]];
            
            // Basic clipping
            if (p1.x < -2000 || p1.x > canvas.width+2000 || p1.y < -2000 || p1.y > canvas.height+2000) continue;

            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
        }
        ctx.stroke();
    }

    // DRAW POINTS
    if (app.style.points) {
        ctx.fillStyle = "#ffffff";
        for(let v of projectedVerts) {
            if (v.x < -50 || v.x > canvas.width+50 || v.y < -50 || v.y > canvas.height+50) continue;
            ctx.beginPath();
            ctx.arc(v.x, v.y, 3, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
