<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Atelier 4D — PINKARIUM</title>
    <!-- Favicon -->
    <link rel="icon" href="https://pinkara.github.io/PINKARIUM/favicon/favicon.ico" sizes="any">
    <link rel="icon" type="image/png" href="https://pinkara.github.io/PINKARIUM/favicon/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="https://pinkara.github.io/PINKARIUM/favicon/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="https://pinkara.github.io/PINKARIUM/favicon/favicon-48x48.png" sizes="48x48">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="icon" type="image/png" href="https://pinkara.github.io/PINKARIUM/favicon/android-chrome-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="https://pinkara.github.io/PINKARIUM/favicon/android-chrome-512x512.png" sizes="512x512">
    <link rel="apple-touch-icon" href="https://pinkara.github.io/PINKARIUM/favicon/apple-touch-icon.png">
    <link rel="mask-icon" href="https://pinkara.github.io/PINKARIUM/favicon/safari-pinned-tab.svg" color="#5bbad5">
    <link rel="icon" href="https://pinkara.github.io/PINKARIUM/favicon/favicon.svg" type="image/svg+xml">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Polices -->
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;700&family=Inter:wght@400;600;800&display=swap" rel="stylesheet">

    <!-- MathJax -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <style>
        /* =========================
           TOKYO NIGHT THEME
           ========================= */
        :root {
            --tn-bg: #1a1b26;
            --tn-bg-2: #24283b;
            --tn-fg: #c0caf5; 
            --tn-accent: #7aa2f7; 
            --tn-cyan: #7dcfff; 
            --tn-green: #9ece6a;
            --tn-orange: #ff9e64;
            --tn-magenta: #bb9af7;
            --tn-red: #f7768e;
            --tn-border: #414868;
            --tn-comment: #565f89;
        }

        body {
            background-color: var(--tn-bg);
            color: var(--tn-fg);
            font-family: 'Inter', sans-serif;
            margin: 0;
            display: flex;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
        }

        .app-container { display: flex; width: 100%; height: 100%; }

        /* Canvas Area */
        .canvas-area {
            flex: 1;
            position: relative;
            background: #16161e; 
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            border-right: 1px solid var(--tn-border);
            cursor: grab;
        }
        .canvas-area:active { cursor: grabbing; }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* Sidebar */
        .sidebar {
            width: 420px;
            background: var(--tn-bg-2);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: -5px 0 20px rgba(0,0,0,0.3);
            z-index: 10;
            flex-shrink: 0;
        }

        .header-box {
            padding: 16px;
            border-bottom: 1px solid var(--tn-border);
            background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
        }

        .logo-box {
            width: 40px; height: 40px; 
            background: linear-gradient(135deg, var(--tn-magenta), var(--tn-accent)); 
            border-radius: 8px; 
            display: flex; align-items: center; justify-content: center; 
            font-weight: 800; color: #1a1b26; font-size: 1.2rem;
            box-shadow: 0 4px 12px rgba(187, 154, 247, 0.3);
        }

        h1 { color: var(--tn-fg); font-weight: 800; font-size: 1.1rem; margin: 0; }
        .subtitle { color: var(--tn-cyan); font-size: 0.75rem; font-weight: 500; opacity: 0.9; margin-top:2px; }

        /* Tabs */
        .tabs { display: flex; background: rgba(0,0,0,0.2); gap: 1px; }
        .tab-btn {
            flex: 1; padding: 12px; background: var(--tn-bg-2); border: none;
            border-bottom: 2px solid transparent; color: var(--tn-comment);
            cursor: pointer; font-weight: 600; font-size: 0.85rem; transition: all 0.2s;
        }
        .tab-btn:hover { color: var(--tn-fg); background: rgba(255,255,255,0.02); }
        .tab-btn.active { color: var(--tn-magenta); border-bottom-color: var(--tn-magenta); background: rgba(187, 154, 247, 0.05); }

        /* Panels */
        .content-scroll { flex: 1; overflow-y: auto; padding: 16px; }
        .panel { display: none; animation: fadeIn 0.3s ease; }
        .panel.active { display: block; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }

        /* Controls */
        .control-group {
            background: rgba(0,0,0,0.2); border: 1px solid var(--tn-border);
            padding: 14px; border-radius: 8px; margin-bottom: 14px;
        }
        .control-header {
            font-size: 0.7rem; text-transform: uppercase; letter-spacing: 1px;
            color: var(--tn-accent); margin-bottom: 12px; font-weight: 700; display: flex; justify-content: space-between;
        }

        label { display: block; font-size: 0.8rem; margin-bottom: 6px; color: var(--tn-fg); margin-top: 10px; }
        .val-display { float: right; font-family: 'JetBrains Mono'; font-size: 0.75rem; color: var(--tn-cyan); }

        /* Inputs */
        select, input[type="text"] {
            width: 100%; background: #141621; border: 1px solid var(--tn-border);
            color: var(--tn-fg); padding: 8px; border-radius: 4px; font-size: 0.8rem; outline: none;
            font-family: 'JetBrains Mono', monospace; cursor: pointer;
        }
        input[type="range"] {
            width: 100%; accent-color: var(--tn-magenta); height: 4px; background: rgba(255,255,255,0.1); border-radius: 2px; cursor: pointer; margin-top: 6px;
        }
        input[type="color"] {
            width: 100%; height: 32px; border: none; background: transparent; cursor: pointer; border-radius: 4px;
        }

        /* Checkbox custom */
        .chk-container { display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; font-size: 0.85rem; }
        input[type="checkbox"] { accent-color: var(--tn-green); transform: scale(1.2); cursor: pointer; }

        /* Formula Box */
        .math-block {
            background: rgba(0,0,0,0.3); padding: 12px; border-radius: 6px;
            border-left: 3px solid var(--tn-magenta); margin-bottom: 12px; font-size: 0.9rem;
        }

        /* Overlay UI */
        .canvas-overlay {
            position: absolute; bottom: 20px; left: 20px;
            background: rgba(26, 27, 38, 0.8); backdrop-filter: blur(4px);
            padding: 10px 14px; border-radius: 6px; border: 1px solid var(--tn-border);
            pointer-events: none; font-size: 0.75rem; color: var(--tn-comment);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
        .key { color: var(--tn-magenta); font-weight: bold; font-family: 'JetBrains Mono'; background: rgba(255,255,255,0.1); padding: 2px 4px; border-radius: 4px; }
        .key.active { background: var(--tn-orange); color: #000; }

        @media (max-width: 900px) {
            .app-container { flex-direction: column; }
            .sidebar { width: 100%; height: 50%; order: 2; }
            .canvas-area { height: 50%; border-right: none; border-bottom: 1px solid var(--tn-border); order: 1; }
        }
    </style>
</head>
<body>

<div class="app-container">
  
  <!-- CANVAS AREA -->
  <div class="canvas-area">
    <canvas id="glCanvas"></canvas>
    <div class="canvas-overlay">
        <div style="margin-bottom:4px; color:var(--tn-fg); font-weight:bold;">CONTRÔLES</div>
        <div style="line-height: 1.6;">
            <span class="key" id="badgeShift">SHIFT</span> + Drag : Rotation 3D<br>
            <span class="key" id="badgeCtrl">CTRL</span> + Drag : Rotation 4D<br>
            <span class="key">R</span> : Reset Position
        </div>
    </div>
  </div>

  <!-- SIDEBAR -->
  <div class="sidebar">
    <div class="header-box">
      <div style="display: flex; gap: 12px; align-items: center;">
        <div class="logo-box">4D</div>
        <div>
          <h1>Atelier - 4D</h1>
          <div class="subtitle">Moteur Physique & Rendu Hybride</div>
        </div>
      </div>
    </div>
    
    <div class="tabs">
      <button class="tab-btn active" onclick="setTab('lab')">Labo</button>
      <button class="tab-btn" onclick="setTab('theory')">Théorie</button>
    </div>

    <div class="content-scroll">
      
      <!-- ONGLET LABO -->
      <div id="panel-lab" class="panel active">
        
        <!-- GEOMETRY -->
        <div class="control-group">
            <div class="control-header">GÉOMÉTRIE</div>
            <label>Objet</label>
            <select id="shapeSelect">
                <option value="tesseract">Tesseract (Hypercube)</option>
                <option value="glome">Glome (Hypersphère)</option>
                <option value="toroid">Toroïde de Clifford</option>
                <option value="cube">Cube (3D)</option>
                <option value="cylinder">Cylindre (3D)</option>
                <option value="16cell">16-Cellules (Orthoplex)</option>
                <option value="pentachoron">Pentachoron (Simplex)</option>
                <option value="oloid3D">Oloïde (3D)</option>
            </select>

            <label>Zoom <span id="val-zoom" class="val-display">250</span></label>
            <input type="range" id="scaleInput" min="50" max="600" value="250">
        </div>

        <!-- PROJECTION -->
        <div class="control-group">
            <div class="control-header">PROJECTION 4D → 3D</div>
            
            <label>Algorithme</label>
            <select id="projectionType">
                <option value="perspective">Perspective (Stéréographique)</option>
                <option value="ortho">Orthographique (Plate)</option>
            </select>

            <label>Profondeur W (Caméra) <span id="val-wdist" class="val-display">2.0</span></label>
            <input type="range" id="wDistance" min="1.1" max="6.0" step="0.1" value="2.0">
        </div>

        <!-- AUTO ROTATION -->
        <div class="control-group">
            <div class="control-header">AUTO-ROTATION</div>
            
            <label style="color:var(--tn-magenta)">Plan X-W (4ème Dimension)</label>
            <input type="range" id="autoXW" min="-0.03" max="0.03" step="0.001" value="0.005">
            
            <label style="color:var(--tn-cyan)">Plan Z-W (4ème Dimension)</label>
            <input type="range" id="autoZW" min="-0.03" max="0.03" step="0.001" value="0.002">
            
            <div style="margin-top: 12px; padding-top:10px; border-top:1px solid rgba(255,255,255,0.05)">
                <button id="resetBtn" style="width:100%; padding:8px; background:rgba(247, 118, 142, 0.1); border:1px solid var(--tn-red); color:var(--tn-red); border-radius:4px; cursor:pointer; font-weight:bold; font-size:0.8rem; transition:0.2s">STOP & RESET</button>
            </div>
        </div>

        <!-- STYLE -->
        <div class="control-group">
            <div class="control-header">RENDU & STYLE</div>
            
            <div class="chk-container">
                <span>Afficher Arêtes</span>
                <input type="checkbox" id="showEdges" checked>
            </div>
            <div class="chk-container">
                <span>Afficher Faces</span>
                <input type="checkbox" id="showFaces" checked>
            </div>
            <div class="chk-container">
                <span>Afficher Points</span>
                <input type="checkbox" id="showVertices">
            </div>

            <label>Couleur Principale</label>
            <input type="color" id="neonColor" value="#7aa2f7">

            <label>Opacité Faces <span id="val-alpha" class="val-display">0.1</span></label>
            <input type="range" id="faceAlpha" min="0.0" max="0.5" step="0.01" value="0.10">
        </div>

      </div>
      
      <!-- ONGLET THÉORIE -->
      <div id="panel-theory" class="panel">
        <h2 class="text-lg font-bold mb-4" style="color:var(--tn-fg)">Géométrie 4D</h2>
        
        <p class="text-sm mb-4" style="color:var(--tn-comment); line-height:1.6;">
            Un point dans l'espace 4D est défini par un vecteur à quatre composantes scalaires \((x, y, z, w)\).
        </p>

        <div class="math-block">
            $$ P = \begin{bmatrix} x \\ y \\ z \\ w \end{bmatrix} $$
        </div>

        <h3 class="text-sm font-bold mt-6 mb-2" style="color:var(--tn-cyan)">La Sphère 4D (Glome)</h3>
        <div class="math-block">
            $$ x^2 + y^2 + z^2 + w^2 = R^2 $$
        </div>
        <p class="text-sm mb-4" style="color:var(--tn-comment);">
            Contrairement à une sphère 3D qui est la surface d'une boule 3D, l'hypersphère est l'hypersurface d'une boule 4D.
        </p>

        <h3 class="text-sm font-bold mt-6 mb-2" style="color:var(--tn-magenta)">Rotations</h3>
        <p class="text-sm mb-4" style="color:var(--tn-comment);">
            En 3D, on tourne autour d'un axe (ligne). En 4D, on tourne autour d'un <strong>Plan</strong> (surface) qui reste fixe. Il y a 6 plans de rotation de base :
            XY, XZ, YZ (classiques) et XW, YW, ZW (nouveaux).
        </p>
      </div>

    </div>
  </div>
</div>

<script>
/**
 * --- MOTEUR MATHÉMATIQUE 4D ---
 * (Logique complète du fichier Final, intégrée dans le Layout "Contrôle")
 */

class Vec4 {
    constructor(x, y, z, w) { this.x = x; this.y = y; this.z = z; this.w = w; }
    
    // Projection Stéréographique 4D -> 3D
    project(wDist, type) {
        if (type === 'ortho') return { x: this.x, y: this.y, z: this.z };
        let wVal = this.w;
        let dist = wDist;
        let denominator = dist - wVal;
        if (Math.abs(denominator) < 0.001) denominator = 0.001; 
        let factor = 1 / denominator;
        return {
            x: this.x * factor,
            y: this.y * factor,
            z: this.z * factor
        };
    }
}

class Mat4 {
    // Rotations 4D (Impliquant W)
    static rotXW(t) { const c=Math.cos(t), s=Math.sin(t); return v => new Vec4(v.x*c - v.w*s, v.y, v.z, v.x*s + v.w*c); }
    static rotYW(t) { const c=Math.cos(t), s=Math.sin(t); return v => new Vec4(v.x, v.y*c - v.w*s, v.z, v.y*s + v.w*c); }
    static rotZW(t) { const c=Math.cos(t), s=Math.sin(t); return v => new Vec4(v.x, v.y, v.z*c - v.w*s, v.z*s + v.w*c); }
    // Rotations 3D appliquées au vecteur 4D
    static rotXY(t) { const c=Math.cos(t), s=Math.sin(t); return v => new Vec4(v.x*c - v.y*s, v.x*s + v.y*c, v.z, v.w); }
    static rotXZ(t) { const c=Math.cos(t), s=Math.sin(t); return v => new Vec4(v.x*c - v.z*s, v.y, v.x*s + v.z*c, v.w); }
    static rotYZ(t) { const c=Math.cos(t), s=Math.sin(t); return v => new Vec4(v.x, v.y*c - v.z*s, v.y*s + v.z*c, v.w); }
}

const Shapes = {
    tesseract: () => {
        let vertices = [];
        for(let i=0; i<16; i++) vertices.push(new Vec4((i&1)?1:-1, (i&2)?1:-1, (i&4)?1:-1, (i&8)?1:-1));
        let edges = [];
        for(let i=0; i<16; i++) for(let j=i+1; j<16; j++) { let x = i^j; if ((x & (x-1)) === 0) edges.push([i, j]); }
        let faces = [];
        const powers = [1, 2, 4, 8];
        for (let d1=0; d1<3; d1++) for (let d2=d1+1; d2<4; d2++) {
            let m1 = powers[d1], m2 = powers[d2], varying = m1 | m2;
            for (let i=0; i<16; i++) if ((i & varying) === 0) faces.push([i, i|m1, i|m1|m2, i|m2]);
        }
        return { vertices, edges, faces }; 
    },
    glome: () => {
        let vertices = [], edges = [], faces = [];
        const latBands = 16, longBands = 16, wBands = 12;
        for (let i = 0; i <= wBands; i++) {
            let theta = (i / wBands) * Math.PI, w = Math.cos(theta), r3d = Math.sin(theta);          
            let startIdx = vertices.length;
            for (let lat = 0; lat <= latBands; lat++) {
                let phi = (lat / latBands) * Math.PI, sinPhi = Math.sin(phi), cosPhi = Math.cos(phi);
                for (let lon = 0; lon <= longBands; lon++) {
                    let psi = (lon / longBands) * 2 * Math.PI;
                    vertices.push(new Vec4(r3d * sinPhi * Math.cos(psi), r3d * cosPhi, r3d * sinPhi * Math.sin(psi), w));
                }
            }
            let ptsPerRow = longBands + 1;
            for (let lat = 0; lat < latBands; lat++) for (let lon = 0; lon < longBands; lon++) {
                let current = startIdx + lat * ptsPerRow + lon, next = current + ptsPerRow;
                faces.push([current, current+1, next+1, next]);
                edges.push([current, current+1]); edges.push([current, next]);
            }
        }
        return { vertices, edges, faces };
    },
    toroid: () => {
        let vertices = [], faces = [], edges = [];
        const U_RES = 30, V_RES = 30;
        for(let i=0; i<U_RES; i++) {
            let u = (i/U_RES) * 2 * Math.PI;
            for(let j=0; j<V_RES; j++) {
                let v = (j/V_RES) * 2 * Math.PI;
                vertices.push(new Vec4(Math.cos(u), Math.sin(u), Math.cos(v), Math.sin(v)));
            }
        }
        for(let i=0; i<U_RES; i++) for(let j=0; j<V_RES; j++) {
            let p1 = i*V_RES + j, p2 = ((i+1)%U_RES)*V_RES + j;
            let p3 = ((i+1)%U_RES)*V_RES + ((j+1)%V_RES), p4 = i*V_RES + ((j+1)%V_RES);
            faces.push([p1, p2, p3, p4]); edges.push([p1, p2]); edges.push([p1, p4]);
        }
        return { vertices, edges, faces };
    },

    
    cube: () => {
        let vertices = []; const r = 1.2;
        for(let i=0; i<8; i++) vertices.push(new Vec4((i&1)?r:-r, (i&2)?r:-r, (i&4)?r:-r, 0));
        let edges = [];
        for(let i=0; i<8; i++) for(let j=i+1; j<8; j++) { let x = i^j; if ((x & (x-1)) === 0) edges.push([i, j]); }
        let faces = [[0,1,3,2], [4,5,7,6], [0,1,5,4], [2,3,7,6], [0,2,6,4], [1,3,7,5]];
        return { vertices, edges, faces };
    },
    cylinder: () => {
        let vertices = [], edges = [], faces = [];
        const steps = 32, h = 1.5, r = 1.0;
        for(let s=0; s<2; s++) {
            let y = s===0 ? -h : h;
            for(let i=0; i<steps; i++) vertices.push(new Vec4(r*Math.cos((i/steps)*Math.PI*2), y, r*Math.sin((i/steps)*Math.PI*2), 0));
        }
        for(let i=0; i<steps; i++) {
            let next = (i+1)%steps, b1 = i, b2 = next, t1 = i + steps, t2 = next + steps;
            faces.push([b1, b2, t2, t1]); edges.push([b1, b2]); edges.push([t1, t2]);
            if(i%4 === 0) edges.push([b1, t1]);
        }
        return { vertices, edges, faces };
    },
    pentachoron: () => {
        const r = 1.2, a = 1 / Math.sqrt(10);
        let vertices = [ new Vec4(r, r, r, a), new Vec4(r, -r, -r, a), new Vec4(-r, r, -r, a), new Vec4(-r, -r, r, a), new Vec4(0, 0, 0, -r/Math.sqrt(2.5)) ];
        let faces = [[0,1,2], [0,1,3], [0,1,4], [0,2,3], [0,2,4], [0,3,4], [1,2,3], [1,2,4], [1,3,4], [2,3,4]];
        let edges = []; for(let i=0;i<5;i++) for(let j=i+1;j<5;j++) edges.push([i,j]);
        return {vertices, edges, faces};
    },
    '16cell': () => {
        let vertices = [];
        for(let i=0; i<4; i++) { let v1=[0,0,0,0]; v1[i]=1.5; vertices.push(new Vec4(...v1)); let v2=[0,0,0,0]; v2[i]=-1.5; vertices.push(new Vec4(...v2)); }
        let edges = []; for(let i=0; i<8; i++) for(let j=i+1; j<8; j++) if((i>>1)!==(j>>1)) edges.push([i,j]);
        let faces = []; for(let i=0; i<8; i++) for(let j=i+1; j<8; j++) for(let k=j+1; k<8; k++) if((i>>1)!==(j>>1) && (j>>1)!==(k>>1) && (i>>1)!==(k>>1)) faces.push([i,j,k]);
        return {vertices, edges, faces};
    },
oloid3D: () => {
    let vertices = [];
    let edges = [];
    let faces = [];
    
    const res = 60; // Résolution pour une courbe lisse
    const r = 1.0;  // Rayon
    const d = r;    // Distance entre les centres (égale au rayon pour l'Oloïde)
    
    // Cercle 1 : Plan Horizontal (XZ), Centre (-d/2, 0, 0)
    // Équation : (x + d/2)^2 + z^2 = r^2
    let offset1 = 0;
    for (let i = 0; i < res; i++) {
        let t = (i / res) * Math.PI * 2;
        vertices.push(new Vec4(-d/2 + Math.cos(t) * r, 0, Math.sin(t) * r, 0));
    }

    // Cercle 2 : Plan Vertical (XY), Centre (d/2, 0, 0)
    // Équation : (x - d/2)^2 + y^2 = r^2
    // Note : On l'oriente pour qu'il soit perpendiculaire au premier
    let offset2 = res;
    for (let i = 0; i < res; i++) {
        let t = (i / res) * Math.PI * 2;
        vertices.push(new Vec4(d/2 + Math.cos(t) * r, Math.sin(t) * r, 0, 0));
    }

    // Génération de l'enveloppe convexe
    // L'Oloïde est une surface réglée reliant les arcs des deux cercles.
    // Une méthode simple pour visualiser le volume est de relier les deux périmètres.
    // (Une triangulation "Convex Hull" précise demanderait un algo plus lourd, 
    // ici on tisse les cercles entre eux).
    for (let i = 0; i < res; i++) {
        let i_next = (i + 1) % res;
        for (let j = 0; j < res; j++) {
            let j_next = (j + 1) % res;
            
            // On ajoute des faces pour créer le volume entre les deux anneaux
            // Astuce visuelle : on peut ne dessiner que si les normales sont cohérentes,
            // mais relier tout le monde crée bien l'enveloppe brute.
            faces.push([i, j + offset2, j_next + offset2, i_next]);
        }
    }
    
    // Arêtes des cercles pour bien voir la structure "squelette"
    for(let i=0; i<res; i++) {
        edges.push([i, (i+1)%res]); // Cercle 1
        edges.push([offset2+i, offset2+(i+1)%res]); // Cercle 2
    }

    return { vertices, edges, faces };
},
};

/**
 * --- APP STATE & RENDERER ---
 */
const canvas = document.getElementById('glCanvas');
const ctx = canvas.getContext('2d');
const app = {
    shape: 'tesseract',
    proj: 'perspective',
    wDist: 2.0,
    scale: 250,
    angles: { x:0, y:0, z:0, xw:0, yw:0, zw:0 },
    auto: { xw: 0.005, zw: 0.002 },
    style: { edges: true, faces: true, vertices: false, color: '#7aa2f7', alpha: 0.10 },
    mouse: { down: false, x: 0, y: 0 },
    keys: { shift: false, ctrl: false },
    geometry: null
};

// Initialization
app.geometry = Shapes.tesseract();
resize();

// --- EVENT LISTENERS (UI BINDING) ---

// Shape
document.getElementById('shapeSelect').addEventListener('change', e => { 
    app.shape = e.target.value; 
    app.geometry = Shapes[app.shape](); 
});
document.getElementById('scaleInput').addEventListener('input', e => {
    app.scale = parseInt(e.target.value);
    document.getElementById('val-zoom').innerText = app.scale;
});

// Projection
document.getElementById('projectionType').addEventListener('change', e => app.proj = e.target.value);
document.getElementById('wDistance').addEventListener('input', e => {
    app.wDist = parseFloat(e.target.value);
    document.getElementById('val-wdist').innerText = app.wDist.toFixed(1);
});

// Auto Rotation
document.getElementById('autoXW').addEventListener('input', e => app.auto.xw = parseFloat(e.target.value));
document.getElementById('autoZW').addEventListener('input', e => app.auto.zw = parseFloat(e.target.value));
document.getElementById('resetBtn').addEventListener('click', () => { 
    app.angles = {x:0,y:0,z:0,xw:0,yw:0,zw:0}; 
    document.getElementById('autoXW').value = 0; app.auto.xw = 0;
    document.getElementById('autoZW').value = 0; app.auto.zw = 0;
});

// Style
document.getElementById('showEdges').addEventListener('change', e => app.style.edges = e.target.checked);
document.getElementById('showFaces').addEventListener('change', e => app.style.faces = e.target.checked);
document.getElementById('showVertices').addEventListener('change', e => app.style.vertices = e.target.checked);
document.getElementById('neonColor').addEventListener('input', e => app.style.color = e.target.value);
document.getElementById('faceAlpha').addEventListener('input', e => {
    app.style.alpha = parseFloat(e.target.value);
    document.getElementById('val-alpha').innerText = app.style.alpha.toFixed(2);
});

// Tabs
window.setTab = (id) => {
    document.querySelectorAll('.panel').forEach(p => p.classList.remove('active'));
    document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
    document.getElementById('panel-'+id).classList.add('active');
    document.querySelector(`.tab-btn[onclick="setTab('${id}')"]`).classList.add('active');
};

// Canvas Resizing
window.addEventListener('resize', resize);
function resize() {
    const parent = canvas.parentElement;
    canvas.width = parent.clientWidth;
    canvas.height = parent.clientHeight;
}

// Interactions (Mouse & Key)
canvas.addEventListener('mousedown', e => { app.mouse.down = true; app.mouse.x = e.clientX; app.mouse.y = e.clientY; });
window.addEventListener('mouseup', () => app.mouse.down = false);

window.addEventListener('keydown', e => {
    if(e.key === 'Shift') { app.keys.shift = true; document.getElementById('badgeShift').classList.add('active'); }
    if(e.key === 'Control') { app.keys.ctrl = true; document.getElementById('badgeCtrl').classList.add('active'); }
    if(e.key.toLowerCase() === 'r') document.getElementById('resetBtn').click();
});
window.addEventListener('keyup', e => {
    if(e.key === 'Shift') { app.keys.shift = false; document.getElementById('badgeShift').classList.remove('active'); }
    if(e.key === 'Control') { app.keys.ctrl = false; document.getElementById('badgeCtrl').classList.remove('active'); }
});

canvas.addEventListener('mousemove', e => {
    if (!app.mouse.down) return;
    const dx = (e.clientX - app.mouse.x) * 0.008;
    const dy = (e.clientY - app.mouse.y) * 0.008;
    app.mouse.x = e.clientX; app.mouse.y = e.clientY;

    if (app.keys.ctrl) {
        app.angles.xw += dx;
        app.angles.yw -= dy;
    } else {
        // Default (Shift or None) is 3D rotation
        app.angles.y -= dx; 
        app.angles.x += dy;
    }
});

/**
 * --- RENDER LOOP ---
 */
function hexToRgb(hex) {
    let result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : {r:0,g:0,b:0};
}

function loop() {
    // Clear
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    
    // Auto Rotation Step
    app.angles.zw += app.auto.zw;
    app.angles.xw += app.auto.xw;

    // Pre-calculate rotation matrices
    const rXW = Mat4.rotXW(app.angles.xw);
    const rYW = Mat4.rotYW(app.angles.yw);
    const rZW = Mat4.rotZW(app.angles.zw);
    
    const cosX = Math.cos(app.angles.x), sinX = Math.sin(app.angles.x);
    const cosY = Math.cos(app.angles.y), sinY = Math.sin(app.angles.y);

    // Transform all vertices
    let projectedVerts = app.geometry.vertices.map((v, i) => {
        let p = new Vec4(v.x, v.y, v.z, v.w);
        
        // 4D Rotations
        p = rXW(p); p = rYW(p); p = rZW(p);
        
        // 4D -> 3D Projection
        let p3 = p.project(app.wDist, app.proj);
        
        // 3D Rotations (XY View)
        let x = p3.x, y = p3.y, z = p3.z;
        let y2 = y * cosX - z * sinX;
        let z2 = y * sinX + z * cosX;
        let x2 = x * cosY - z2 * sinY;
        let z3 = x * sinY + z2 * cosY;
        
        // 3D -> 2D Projection (Perspective)
        let fov = 4;
        let persp = app.proj !== 'ortho' ? fov / (fov - z3 * 0.2) : 1;
        
        return {
            x: cx + x2 * app.scale * persp,
            y: cy + y2 * app.scale * persp,
            z: z3,
            idx: i
        };
    });

    // Face Sorting (Painter's Algorithm)
    let facesToDraw = [];
    if (app.style.faces) {
        for (let f of app.geometry.faces) {
            let zSum = 0;
            for(let idx of f) zSum += projectedVerts[idx].z;
            facesToDraw.push({ indices: f, z: zSum / f.length });
        }
        facesToDraw.sort((a, b) => a.z - b.z);
    }

    // Colors
    const rgb = hexToRgb(app.style.color);
    const colorStroke = app.style.color;
    const colorFill = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${app.style.alpha})`;

    // Draw Faces
    if (app.style.faces) {
        ctx.fillStyle = colorFill;
        ctx.strokeStyle = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${app.style.alpha * 1.5})`; 
        ctx.lineWidth = 0.5;

        for (let face of facesToDraw) {
            ctx.beginPath();
            let v0 = projectedVerts[face.indices[0]];
            ctx.moveTo(v0.x, v0.y);
            for (let j=1; j<face.indices.length; j++) {
                let v = projectedVerts[face.indices[j]];
                ctx.lineTo(v.x, v.y);
            }
            ctx.closePath();
            ctx.fill();
            if(!app.style.edges) ctx.stroke();
        }
    }

    // Draw Edges
    if (app.style.edges) {
        ctx.strokeStyle = colorStroke;
        ctx.lineWidth = 1; 
        ctx.beginPath();
        for (let edge of app.geometry.edges) {
            let p1 = projectedVerts[edge[0]];
            let p2 = projectedVerts[edge[1]];
            // Culling very distant or out of bound points
            if ((p1.x < -100 && p2.x < -100) || (p1.x > canvas.width+100 && p2.x > canvas.width+100)) continue;
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
        }
        ctx.stroke();
    }

    // Draw Vertices
    if (app.style.vertices) {
        ctx.fillStyle = "#fff";
        for (let p of projectedVerts) {
            ctx.beginPath();
            ctx.arc(p.x, p.y, 2.5, 0, Math.PI*2);
            ctx.fill();
        }
    }

    requestAnimationFrame(loop);
}

// Start
loop();
</script>
</body>
</html>
